#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
pub mod database {
    use sea_orm::{ConnectOptions, Database, DatabaseConnection, DbErr};
    use std::time::Duration;
    use tracing::log::LevelFilter;
    pub const DB_ERR_MESSAGE: &str = "Somthing is wrong about Database";
    pub async fn init_db() -> Result<DatabaseConnection, DbErr> {
        let database_url = std::env::var("DATABASE_URL").unwrap();
        let mut opt = ConnectOptions::new(database_url);
        opt.max_connections(100)
            .min_connections(5)
            .connect_timeout(Duration::from_secs(8))
            .acquire_timeout(Duration::from_secs(8))
            .idle_timeout(Duration::from_secs(8))
            .max_lifetime(Duration::from_secs(8))
            .sqlx_logging(true)
            .sqlx_logging_level(LevelFilter::Info)
            .set_schema_search_path("public");
        Ok(Database::connect(opt).await?)
    }
}
pub mod front {
    pub mod page {
        pub mod component {
            pub mod login {
                use dioxus::fullstack::{
                    Form, body::Body, extract::State, http::HeaderValue,
                    response::Response,
                };
                use dioxus::prelude::*;
                use dioxus::fullstack::{Cookie, TypedHeader};
                use reqwest::header::{LOCATION, SET_COOKIE};
                use crate::front::util::add_no_cache_headers;
                use crate::resources::dto::fullstack_extension::AppDatabase;
                use crate::resources::dto::user::ReqUser;
                ///Properties for the [`Login`] component.
                #[allow(missing_docs)]
                #[allow(non_camel_case_types)]
                pub struct LoginProps {
                    pub is_login: bool,
                }
                impl LoginProps {
                    /**
Create a builder for building `LoginProps`.
On the builder, call `.is_login(...)` to set the values of the fields.
Finally, call `.build()` to create the instance of `LoginProps`.
                    */
                    #[allow(dead_code, clippy::type_complexity)]
                    pub fn builder() -> LoginPropsBuilder<((),)> {
                        LoginPropsBuilder {
                            fields: ((),),
                            _phantom: ::core::default::Default::default(),
                        }
                    }
                }
                #[must_use]
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, non_snake_case)]
                pub struct LoginPropsBuilder<TypedBuilderFields> {
                    fields: TypedBuilderFields,
                    _phantom: (),
                }
                impl dioxus_core::Properties for LoginProps
                where
                    Self: Clone,
                {
                    type Builder = LoginPropsBuilder<((),)>;
                    fn builder() -> Self::Builder {
                        LoginProps::builder()
                    }
                    fn memoize(&mut self, new: &Self) -> bool {
                        let equal = self == new;
                        if !equal {
                            let new_clone = new.clone();
                            self.is_login = new_clone.is_login;
                        }
                        equal
                    }
                }
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, non_snake_case)]
                pub trait LoginPropsBuilder_Optional<T> {
                    fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
                }
                impl<T> LoginPropsBuilder_Optional<T> for () {
                    fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                        default()
                    }
                }
                impl<T> LoginPropsBuilder_Optional<T> for (T,) {
                    fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                        self.0
                    }
                }
                #[allow(dead_code, non_camel_case_types, missing_docs)]
                impl LoginPropsBuilder<((),)> {
                    #[allow(clippy::type_complexity)]
                    pub fn is_login(
                        self,
                        is_login: bool,
                    ) -> LoginPropsBuilder<((bool,),)> {
                        let is_login = (is_login,);
                        let (_,) = self.fields;
                        LoginPropsBuilder {
                            fields: (is_login,),
                            _phantom: self._phantom,
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, non_snake_case)]
                pub enum LoginPropsBuilder_Error_Repeated_field_is_login {}
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, missing_docs)]
                impl LoginPropsBuilder<((bool,),)> {
                    #[deprecated(note = "Repeated field is_login")]
                    #[allow(clippy::type_complexity)]
                    pub fn is_login(
                        self,
                        _: LoginPropsBuilder_Error_Repeated_field_is_login,
                    ) -> LoginPropsBuilder<((bool,),)> {
                        self
                    }
                }
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, non_snake_case)]
                pub enum LoginPropsBuilder_Error_Missing_required_field_is_login {}
                #[doc(hidden)]
                #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
                impl LoginPropsBuilder<((),)> {
                    #[deprecated(note = "Missing required field is_login")]
                    pub fn build(
                        self,
                        _: LoginPropsBuilder_Error_Missing_required_field_is_login,
                    ) -> LoginProps {
                        ::core::panicking::panic("explicit panic")
                    }
                }
                #[allow(dead_code, non_camel_case_types, missing_docs)]
                impl LoginPropsBuilder<((bool,),)> {
                    pub fn build(self) -> LoginProps {
                        let (is_login,) = self.fields;
                        let is_login = is_login.0;
                        LoginProps { is_login }
                    }
                }
                impl ::core::clone::Clone for LoginProps {
                    #[inline]
                    fn clone(&self) -> Self {
                        Self {
                            is_login: ::core::clone::Clone::clone(&self.is_login),
                        }
                    }
                }
                impl ::core::cmp::PartialEq for LoginProps {
                    #[inline]
                    fn eq(&self, other: &Self) -> bool {
                        self.is_login == other.is_login && true
                    }
                }
                /**# Props
*For details, see the [props struct definition](LoginProps).**/
                ///- [`is_login`](LoginProps::is_login) : `bool`
                #[allow(non_snake_case)]
                pub fn Login(LoginProps { mut is_login }: LoginProps) -> Element {
                    {
                        {
                            let username = use_loader(|| get_user_info_from_cookie())?();
                            if is_login {
                                dioxus_core::Element::Ok({
                                    fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                                        static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                                            dioxus_core::internal::HotReloadedTemplate,
                                        > = ::std::sync::OnceLock::new();
                                        if __ORIGINAL_TEMPLATE.get().is_none() {
                                            _ = __ORIGINAL_TEMPLATE
                                                .set(
                                                    dioxus_core::internal::HotReloadedTemplate::new(
                                                        None,
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                dioxus_core::internal::HotReloadDynamicNode::Dynamic(0usize),
                                                            ]),
                                                        ),
                                                        ::alloc::vec::Vec::new(),
                                                        ::alloc::vec::Vec::new(),
                                                        __TEMPLATE_ROOTS,
                                                    ),
                                                );
                                        }
                                        __ORIGINAL_TEMPLATE.get().unwrap()
                                    }
                                    let __template_read = {
                                        use dioxus_signals::ReadableExt;
                                        static __NORMALIZED_FILE: &'static str = {
                                            const PATH: &str = ::const_format::pmr::__AssertStr {
                                                x: {
                                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                            "fullstack/src/front/page/component/login.rs",
                                                            "\\\\",
                                                            "/",
                                                        )
                                                        .conv();
                                                    {
                                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                        const OS: &::const_format::pmr::str = unsafe {
                                                            {
                                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                let string: &'static ::const_format::pmr::str = {
                                                                    ::const_format::__hidden_utils::PtrToRef {
                                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                    }
                                                                        .reff
                                                                };
                                                                string
                                                            }
                                                        };
                                                        OS
                                                    }
                                                },
                                            }
                                                .x;
                                            ::const_format::pmr::__AssertStr {
                                                x: {
                                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                            PATH,
                                                            '\\',
                                                            "/",
                                                        )
                                                        .conv();
                                                    {
                                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                        const OS: &::const_format::pmr::str = unsafe {
                                                            {
                                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                let string: &'static ::const_format::pmr::str = {
                                                                    ::const_format::__hidden_utils::PtrToRef {
                                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                    }
                                                                        .reff
                                                                };
                                                                string
                                                            }
                                                        };
                                                        OS
                                                    }
                                                },
                                            }
                                                .x
                                        };
                                        static __TEMPLATE: dioxus_signals::GlobalSignal<
                                            Option<dioxus_core::internal::HotReloadedTemplate>,
                                        > = dioxus_signals::GlobalSignal::with_location(
                                            || None::<dioxus_core::internal::HotReloadedTemplate>,
                                            __NORMALIZED_FILE,
                                            20u32,
                                            9u32,
                                            0usize,
                                        );
                                        dioxus_core::Runtime::try_current()
                                            .map(|_| __TEMPLATE.read())
                                    };
                                    let __template_read = match __template_read
                                        .as_ref()
                                        .map(|__template_read| __template_read.as_ref())
                                    {
                                        Some(Some(__template_read)) => &__template_read,
                                        _ => __original_template(),
                                    };
                                    let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(
                                                            format_args!("{0}", username.as_ref().unwrap()),
                                                        )
                                                    })
                                                    .to_string(),
                                            ]),
                                        ),
                                    );
                                    let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                        dioxus_core::DynamicNode::Text(
                                            dioxus_core::VText::new(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("Wellcome {0}", username.as_ref().unwrap()),
                                                    )
                                                }),
                                            ),
                                        ),
                                    ];
                                    let __dynamic_attributes: [Box<
                                        [dioxus_core::Attribute],
                                    >; 0usize] = [];
                                    #[doc(hidden)]
                                    static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::p::TAG_NAME,
                                                namespace: dioxus_elements::p::NAME_SPACE,
                                                attrs: &[],
                                                children: &[
                                                    dioxus_core::TemplateNode::Dynamic {
                                                        id: 0usize,
                                                    },
                                                ],
                                            }
                                        },
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::form::TAG_NAME,
                                                namespace: dioxus_elements::form::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::form::method.0,
                                                        namespace: dioxus_elements::form::method.1,
                                                        value: "post",
                                                    },
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::form::action.0,
                                                        namespace: dioxus_elements::form::action.1,
                                                        value: "/front/logout/action",
                                                    },
                                                ],
                                                children: &[
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::button::TAG_NAME,
                                                            namespace: dioxus_elements::button::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "Logout",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                ],
                                            }
                                        },
                                    ];
                                    {
                                        let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                                            Vec::from(__dynamic_nodes),
                                            Vec::from(__dynamic_attributes),
                                            __dynamic_literal_pool,
                                        );
                                        __dynamic_value_pool.render_with(__template_read)
                                    }
                                })
                            } else {
                                dioxus_core::Element::Ok({
                                    fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                                        static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                                            dioxus_core::internal::HotReloadedTemplate,
                                        > = ::std::sync::OnceLock::new();
                                        if __ORIGINAL_TEMPLATE.get().is_none() {
                                            _ = __ORIGINAL_TEMPLATE
                                                .set(
                                                    dioxus_core::internal::HotReloadedTemplate::new(
                                                        None,
                                                        ::alloc::vec::Vec::new(),
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                dioxus_core::internal::HotReloadDynamicAttribute::Dynamic(
                                                                    0usize,
                                                                ),
                                                                dioxus_core::internal::HotReloadDynamicAttribute::Dynamic(
                                                                    1usize,
                                                                ),
                                                            ]),
                                                        ),
                                                        ::alloc::vec::Vec::new(),
                                                        __TEMPLATE_ROOTS,
                                                    ),
                                                );
                                        }
                                        __ORIGINAL_TEMPLATE.get().unwrap()
                                    }
                                    let __template_read = {
                                        use dioxus_signals::ReadableExt;
                                        static __NORMALIZED_FILE: &'static str = {
                                            const PATH: &str = ::const_format::pmr::__AssertStr {
                                                x: {
                                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                            "fullstack/src/front/page/component/login.rs",
                                                            "\\\\",
                                                            "/",
                                                        )
                                                        .conv();
                                                    {
                                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                        const OS: &::const_format::pmr::str = unsafe {
                                                            {
                                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                let string: &'static ::const_format::pmr::str = {
                                                                    ::const_format::__hidden_utils::PtrToRef {
                                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                    }
                                                                        .reff
                                                                };
                                                                string
                                                            }
                                                        };
                                                        OS
                                                    }
                                                },
                                            }
                                                .x;
                                            ::const_format::pmr::__AssertStr {
                                                x: {
                                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                            PATH,
                                                            '\\',
                                                            "/",
                                                        )
                                                        .conv();
                                                    {
                                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                        const OS: &::const_format::pmr::str = unsafe {
                                                            {
                                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                let string: &'static ::const_format::pmr::str = {
                                                                    ::const_format::__hidden_utils::PtrToRef {
                                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                    }
                                                                        .reff
                                                                };
                                                                string
                                                            }
                                                        };
                                                        OS
                                                    }
                                                },
                                            }
                                                .x
                                        };
                                        static __TEMPLATE: dioxus_signals::GlobalSignal<
                                            Option<dioxus_core::internal::HotReloadedTemplate>,
                                        > = dioxus_signals::GlobalSignal::with_location(
                                            || None::<dioxus_core::internal::HotReloadedTemplate>,
                                            __NORMALIZED_FILE,
                                            29u32,
                                            9u32,
                                            0usize,
                                        );
                                        dioxus_core::Runtime::try_current()
                                            .map(|_| __TEMPLATE.read())
                                    };
                                    let __template_read = match __template_read
                                        .as_ref()
                                        .map(|__template_read| __template_read.as_ref())
                                    {
                                        Some(Some(__template_read)) => &__template_read,
                                        _ => __original_template(),
                                    };
                                    let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                                        ::alloc::vec::Vec::new(),
                                    );
                                    let __dynamic_nodes: [dioxus_core::DynamicNode; 0usize] = [];
                                    let __dynamic_attributes: [Box<
                                        [dioxus_core::Attribute],
                                    >; 2usize] = [
                                        Box::new([
                                            {
                                                dioxus_core::Attribute::new(
                                                    dioxus_elements::input::value.0,
                                                    {
                                                        if let Some(username) = username {
                                                            ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(format_args!("{0}", username))
                                                                })
                                                                .to_string()
                                                        } else {
                                                            "".to_string()
                                                        }
                                                    },
                                                    dioxus_elements::input::value.1,
                                                    dioxus_elements::input::value.2,
                                                )
                                            },
                                        ]),
                                        Box::new([
                                            {
                                                dioxus_core::Attribute::new(
                                                    dioxus_elements::input::value.0,
                                                    true,
                                                    dioxus_elements::input::value.1,
                                                    dioxus_elements::input::value.2,
                                                )
                                            },
                                        ]),
                                    ];
                                    #[doc(hidden)]
                                    static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::form::TAG_NAME,
                                                namespace: dioxus_elements::form::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::form::method.0,
                                                        namespace: dioxus_elements::form::method.1,
                                                        value: "post",
                                                    },
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::form::action.0,
                                                        namespace: dioxus_elements::form::action.1,
                                                        value: "/front/login/action",
                                                    },
                                                ],
                                                children: &[
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::label::TAG_NAME,
                                                            namespace: dioxus_elements::label::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "Id: ",
                                                                },
                                                                {
                                                                    dioxus_core::TemplateNode::Element {
                                                                        tag: dioxus_elements::elements::input::TAG_NAME,
                                                                        namespace: dioxus_elements::input::NAME_SPACE,
                                                                        attrs: &[
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::name.0,
                                                                                namespace: dioxus_elements::input::name.1,
                                                                                value: "username",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::placeholder.0,
                                                                                namespace: dioxus_elements::input::placeholder.1,
                                                                                value: "Id",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Dynamic {
                                                                                id: 0usize,
                                                                            },
                                                                        ],
                                                                        children: &[],
                                                                    }
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::br::TAG_NAME,
                                                            namespace: dioxus_elements::br::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::label::TAG_NAME,
                                                            namespace: dioxus_elements::label::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "Pw: ",
                                                                },
                                                                {
                                                                    dioxus_core::TemplateNode::Element {
                                                                        tag: dioxus_elements::elements::input::TAG_NAME,
                                                                        namespace: dioxus_elements::input::NAME_SPACE,
                                                                        attrs: &[
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::name.0,
                                                                                namespace: dioxus_elements::input::name.1,
                                                                                value: "password",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::placeholder.0,
                                                                                namespace: dioxus_elements::input::placeholder.1,
                                                                                value: "Pw",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::r#type.0,
                                                                                namespace: dioxus_elements::input::r#type.1,
                                                                                value: "password",
                                                                            },
                                                                        ],
                                                                        children: &[],
                                                                    }
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::br::TAG_NAME,
                                                            namespace: dioxus_elements::br::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::label::TAG_NAME,
                                                            namespace: dioxus_elements::label::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "save id",
                                                                },
                                                                {
                                                                    dioxus_core::TemplateNode::Element {
                                                                        tag: dioxus_elements::elements::input::TAG_NAME,
                                                                        namespace: dioxus_elements::input::NAME_SPACE,
                                                                        attrs: &[
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::name.0,
                                                                                namespace: dioxus_elements::input::name.1,
                                                                                value: "save_id",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::input::r#type.0,
                                                                                namespace: dioxus_elements::input::r#type.1,
                                                                                value: "checkbox",
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Dynamic {
                                                                                id: 1usize,
                                                                            },
                                                                        ],
                                                                        children: &[],
                                                                    }
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::button::TAG_NAME,
                                                            namespace: dioxus_elements::button::NAME_SPACE,
                                                            attrs: &[],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "login",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                ],
                                            }
                                        },
                                    ];
                                    {
                                        let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                                            Vec::from(__dynamic_nodes),
                                            Vec::from(__dynamic_attributes),
                                            __dynamic_literal_pool,
                                        );
                                        __dynamic_value_pool.render_with(__template_read)
                                    }
                                })
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                #[doc(hidden)]
                mod Login_completions {
                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    /// This enum is generated to help autocomplete the braces after the component. It does nothing
                    pub enum Component {
                        Login {},
                    }
                }
                #[allow(unused)]
                pub use Login_completions::Component::Login;
                /**# Handler information
- Method: `post`
- Path: `/front/login/user_info`*/
                #[deny(
                    unexpected_cfgs,
                    reason = "
==========================================================================================
  Using Dioxus Server Functions requires a `server` feature flag in your `Cargo.toml`.
  Please add the following to your `Cargo.toml`:

  ```toml
  [features]
  server = [\"dioxus/server\"]
  ```

  To enable better Rust-Analyzer support, you can make `server` a default feature:
  ```toml
  [features]
  default = [\"web\", \"server\"]
  web = [\"dioxus/web\"]
  server = [\"dioxus/server\"]
  ```
==========================================================================================
        "
                )]
                async fn get_user_info_from_cookie() -> Result<Option<String>> {
                    use dioxus_fullstack::serde as serde;
                    use dioxus_fullstack::{
                        ServerFnEncoder, ServerFnDecoder, FullstackContext,
                        ExtractRequest, EncodeRequest, RequestDecodeResult,
                        RequestDecodeErr, MakeAxumResponse, MakeAxumError,
                    };
                    #[serde(crate = "serde")]
                    struct __QueryParams__ {}
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __QueryParams__ {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private228::PhantomData<__QueryParams__>,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = __QueryParams__;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct __QueryParams__",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "__QueryParams__",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            __QueryParams__,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for __QueryParams__ {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "__QueryParams__",
                                    false as usize,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[serde(crate = "serde")]
                    struct ___Body_Serialize___ {}
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for ___Body_Serialize___ {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "___Body_Serialize___",
                                    false as usize,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for ___Body_Serialize___ {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private228::PhantomData<
                                        ___Body_Serialize___,
                                    >,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ___Body_Serialize___;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct ___Body_Serialize___",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private228::Ok(___Body_Serialize___ {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        _serde::__private228::Ok(___Body_Serialize___ {})
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "___Body_Serialize___",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            ___Body_Serialize___,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    const __ENDPOINT_PATH: &str = ::const_format::pmr::__AssertStr {
                        x: {
                            use ::const_format::__cf_osRcTFl4A;
                            ({
                                #[doc(hidden)]
                                #[allow(unused_mut, non_snake_case)]
                                const CONCATP_NHPMWYD3NJA: &[__cf_osRcTFl4A::pmr::PArgument] = {
                                    let fmt = __cf_osRcTFl4A::pmr::FormattingFlags::NEW;
                                    &[
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("/front/login/user_info")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                    ]
                                };
                                {
                                    #[doc(hidden)]
                                    const ARR_LEN: usize = ::const_format::pmr::PArgument::calc_len(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    const CONCAT_ARR: &::const_format::pmr::LenAndArray<
                                        [u8; ARR_LEN],
                                    > = &::const_format::pmr::__priv_concatenate(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    #[allow(clippy::transmute_ptr_to_ptr)]
                                    const CONCAT_STR: &str = unsafe {
                                        let slice = ::const_format::pmr::transmute::<
                                            &[u8; ARR_LEN],
                                            &[u8; CONCAT_ARR.len],
                                        >(&CONCAT_ARR.array);
                                        {
                                            let bytes: &'static [::const_format::pmr::u8] = slice;
                                            let string: &'static ::const_format::pmr::str = {
                                                ::const_format::__hidden_utils::PtrToRef {
                                                    ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                }
                                                    .reff
                                            };
                                            string
                                        }
                                    };
                                    CONCAT_STR
                                }
                            })
                        },
                    }
                        .x;
                    {
                        _ = dioxus_fullstack::assert_is_result::<
                            Result<Option<String>>,
                        >();
                        let verify_token = (&&&&&&&&&&&&&&ServerFnEncoder::<
                            ___Body_Serialize___,
                            (),
                        >::new())
                            .verify_can_serialize();
                        dioxus_fullstack::assert_can_encode(verify_token);
                        let decode_token = (&&&&&ServerFnDecoder::<
                            Result<Option<String>>,
                        >::new())
                            .verify_can_deserialize();
                        dioxus_fullstack::assert_can_decode(decode_token);
                    };
                    {
                        async fn get_user_info_from_cookie(
                            header: TypedHeader<Cookie>,
                        ) -> Result<Option<String>> {
                            Ok(header.0.get("username").map(|m| m.to_string()))
                        }
                        #[allow(clippy::unused_unit)]
                        fn __inner__function__(
                            ___state: dioxus_server::axum::extract::State<
                                FullstackContext,
                            >,
                            ___request: dioxus_server::axum::extract::Request,
                        ) -> std::pin::Pin<
                            Box<
                                dyn std::future::Future<
                                    Output = dioxus_server::axum::response::Response,
                                >,
                            >,
                        > {
                            Box::pin(async move {
                                match (&&&&&&&&&&&&&&ServerFnEncoder::<
                                    ___Body_Serialize___,
                                    (),
                                >::new())
                                    .extract_axum(___state.0, ___request, |data| { () })
                                    .await
                                {
                                    Ok(
                                        (
                                            (),
                                            (
                                                dioxus_server::axum::extract::Path(()),
                                                dioxus_fullstack::payloads::Query(__QueryParams__ {}),
                                                ___sarg___0,
                                            ),
                                        ),
                                    ) => {
                                        let res = get_user_info_from_cookie(___sarg___0).await;
                                        let encoded = (&&&&&&ServerFnDecoder::<
                                            Result<Option<String>>,
                                        >::new())
                                            .make_axum_response(res);
                                        (&&&&&ServerFnDecoder::<Result<Option<String>>>::new())
                                            .make_axum_error(encoded)
                                    }
                                    Err(res) => res,
                                }
                            })
                        }
                        #[allow(non_upper_case_globals)]
                        const _: () = {
                            static __INVENTORY: ::inventory::Node = ::inventory::Node {
                                value: &{
                                    dioxus_server::ServerFunction::new(
                                        dioxus_server::http::Method::POST,
                                        __ENDPOINT_PATH,
                                        || {
                                            dioxus_server::ServerFunction::make_handler(
                                                dioxus_server::http::Method::POST,
                                                __inner__function__,
                                            )
                                        },
                                    )
                                },
                                next: ::inventory::core::cell::UnsafeCell::new(
                                    ::inventory::core::option::Option::None,
                                ),
                            };
                            #[link_section = ".text.startup"]
                            unsafe extern "C" fn __ctor() {
                                unsafe {
                                    ::inventory::ErasedNode::submit(
                                        __INVENTORY.value,
                                        &__INVENTORY,
                                    )
                                }
                            }
                            #[used]
                            #[link_section = ".init_array"]
                            static __CTOR: unsafe extern "C" fn() = __ctor;
                        };
                        let (___sarg___0,) = dioxus_fullstack::FullstackContext::extract::<
                            (TypedHeader<Cookie>,),
                            _,
                        >()
                            .await?;
                        return get_user_info_from_cookie(___sarg___0).await;
                    }
                    #[allow(unreachable_code)]
                    {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
                /**# Handler information
- Method: `post`
- Path: `/front/login/action`*/
                #[deny(
                    unexpected_cfgs,
                    reason = "
==========================================================================================
  Using Dioxus Server Functions requires a `server` feature flag in your `Cargo.toml`.
  Please add the following to your `Cargo.toml`:

  ```toml
  [features]
  server = [\"dioxus/server\"]
  ```

  To enable better Rust-Analyzer support, you can make `server` a default feature:
  ```toml
  [features]
  default = [\"web\", \"server\"]
  web = [\"dioxus/web\"]
  server = [\"dioxus/server\"]
  ```
==========================================================================================
        "
                )]
                async fn login_action(
                    #[allow(unused_mut)]
                    ___Arg0: Form<ReqUser>,
                ) -> Result<Response<Body>> {
                    use dioxus_fullstack::serde as serde;
                    use dioxus_fullstack::{
                        ServerFnEncoder, ServerFnDecoder, FullstackContext,
                        ExtractRequest, EncodeRequest, RequestDecodeResult,
                        RequestDecodeErr, MakeAxumResponse, MakeAxumError,
                    };
                    #[serde(crate = "serde")]
                    struct __QueryParams__ {}
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __QueryParams__ {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private228::PhantomData<__QueryParams__>,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = __QueryParams__;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct __QueryParams__",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "__QueryParams__",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            __QueryParams__,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for __QueryParams__ {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "__QueryParams__",
                                    false as usize,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[serde(crate = "serde")]
                    struct ___Body_Serialize___<__Ty0> {
                        ___Arg0: __Ty0,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<__Ty0> _serde::Serialize for ___Body_Serialize___<__Ty0>
                        where
                            __Ty0: _serde::Serialize,
                        {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let mut __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "___Body_Serialize___",
                                    false as usize + 1,
                                )?;
                                _serde::ser::SerializeStruct::serialize_field(
                                    &mut __serde_state,
                                    "___Arg0",
                                    &self.___Arg0,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de, __Ty0> _serde::Deserialize<'de>
                        for ___Body_Serialize___<__Ty0>
                        where
                            __Ty0: _serde::Deserialize<'de>,
                        {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "___Arg0" => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"___Arg0" => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, __Ty0>
                                where
                                    __Ty0: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private228::PhantomData<
                                        ___Body_Serialize___<__Ty0>,
                                    >,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de, __Ty0> _serde::de::Visitor<'de>
                                for __Visitor<'de, __Ty0>
                                where
                                    __Ty0: _serde::Deserialize<'de>,
                                {
                                    type Value = ___Body_Serialize___<__Ty0>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct ___Body_Serialize___",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            __Ty0,
                                        >(&mut __seq)? {
                                            _serde::__private228::Some(__value) => __value,
                                            _serde::__private228::None => {
                                                return _serde::__private228::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct ___Body_Serialize___ with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private228::Ok(___Body_Serialize___ {
                                            ___Arg0: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private228::Option<__Ty0> = _serde::__private228::None;
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private228::Option::is_some(&__field0) {
                                                        return _serde::__private228::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "___Arg0",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private228::Some(
                                                        _serde::de::MapAccess::next_value::<__Ty0>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private228::Some(__field0) => __field0,
                                            _serde::__private228::None => {
                                                _serde::__private228::de::missing_field("___Arg0")?
                                            }
                                        };
                                        _serde::__private228::Ok(___Body_Serialize___ {
                                            ___Arg0: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["___Arg0"];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "___Body_Serialize___",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            ___Body_Serialize___<__Ty0>,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    const __ENDPOINT_PATH: &str = ::const_format::pmr::__AssertStr {
                        x: {
                            use ::const_format::__cf_osRcTFl4A;
                            ({
                                #[doc(hidden)]
                                #[allow(unused_mut, non_snake_case)]
                                const CONCATP_NHPMWYD3NJA: &[__cf_osRcTFl4A::pmr::PArgument] = {
                                    let fmt = __cf_osRcTFl4A::pmr::FormattingFlags::NEW;
                                    &[
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("/front/login/action")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                    ]
                                };
                                {
                                    #[doc(hidden)]
                                    const ARR_LEN: usize = ::const_format::pmr::PArgument::calc_len(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    const CONCAT_ARR: &::const_format::pmr::LenAndArray<
                                        [u8; ARR_LEN],
                                    > = &::const_format::pmr::__priv_concatenate(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    #[allow(clippy::transmute_ptr_to_ptr)]
                                    const CONCAT_STR: &str = unsafe {
                                        let slice = ::const_format::pmr::transmute::<
                                            &[u8; ARR_LEN],
                                            &[u8; CONCAT_ARR.len],
                                        >(&CONCAT_ARR.array);
                                        {
                                            let bytes: &'static [::const_format::pmr::u8] = slice;
                                            let string: &'static ::const_format::pmr::str = {
                                                ::const_format::__hidden_utils::PtrToRef {
                                                    ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                }
                                                    .reff
                                            };
                                            string
                                        }
                                    };
                                    CONCAT_STR
                                }
                            })
                        },
                    }
                        .x;
                    {
                        _ = dioxus_fullstack::assert_is_result::<
                            Result<Response<Body>>,
                        >();
                        let verify_token = (&&&&&&&&&&&&&&ServerFnEncoder::<
                            ___Body_Serialize___<Form<ReqUser>>,
                            (Form<ReqUser>,),
                        >::new())
                            .verify_can_serialize();
                        dioxus_fullstack::assert_can_encode(verify_token);
                        let decode_token = (&&&&&ServerFnDecoder::<
                            Result<Response<Body>>,
                        >::new())
                            .verify_can_deserialize();
                        dioxus_fullstack::assert_can_decode(decode_token);
                    };
                    {
                        async fn login_action(
                            Form(req_user): Form<ReqUser>,
                            state: State<AppDatabase>,
                        ) -> Result<Response<Body>> {
                            use crate::router::api::auth::*;
                            let token = login(
                                    State(state.0.0),
                                    axum::Json(req_user.clone()),
                                )
                                .await?;
                            let mut response = Response::new(Body::empty());
                            let header = response.headers_mut();
                            let jwt_val = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("jwt={0}; Path=/; HttpOnly", token.0.jwt),
                                )
                            });
                            let refresh_val = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "refresh={0}; Path=/; HttpOnly;",
                                        token.0.refresh,
                                    ),
                                )
                            });
                            let username_val = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "username={0}; Path=/; HttpOnly",
                                        req_user.username,
                                    ),
                                )
                            });
                            let save_id_val = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "save_id={0}; Path=/; HttpOnly",
                                        req_user.save_id.unwrap_or(false),
                                    ),
                                )
                            });
                            add_no_cache_headers(header);
                            header.append(SET_COOKIE, HeaderValue::from_str(&jwt_val)?);
                            header
                                .append(SET_COOKIE, HeaderValue::from_str(&refresh_val)?);
                            header
                                .append(SET_COOKIE, HeaderValue::from_str(&username_val)?);
                            header
                                .append(SET_COOKIE, HeaderValue::from_str(&save_id_val)?);
                            Ok(response)
                        }
                        #[allow(clippy::unused_unit)]
                        fn __inner__function__(
                            ___state: dioxus_server::axum::extract::State<
                                FullstackContext,
                            >,
                            ___request: dioxus_server::axum::extract::Request,
                        ) -> std::pin::Pin<
                            Box<
                                dyn std::future::Future<
                                    Output = dioxus_server::axum::response::Response,
                                >,
                            >,
                        > {
                            Box::pin(async move {
                                match (&&&&&&&&&&&&&&ServerFnEncoder::<
                                    ___Body_Serialize___<Form<ReqUser>>,
                                    (Form<ReqUser>,),
                                >::new())
                                    .extract_axum(
                                        ___state.0,
                                        ___request,
                                        |data| { (data.___Arg0,) },
                                    )
                                    .await
                                {
                                    Ok(
                                        (
                                            (___Arg0,),
                                            (
                                                dioxus_server::axum::extract::Path(()),
                                                dioxus_fullstack::payloads::Query(__QueryParams__ {}),
                                                ___sarg___0,
                                            ),
                                        ),
                                    ) => {
                                        let res = login_action(___Arg0, ___sarg___0).await;
                                        let encoded = (&&&&&&ServerFnDecoder::<
                                            Result<Response<Body>>,
                                        >::new())
                                            .make_axum_response(res);
                                        (&&&&&ServerFnDecoder::<Result<Response<Body>>>::new())
                                            .make_axum_error(encoded)
                                    }
                                    Err(res) => res,
                                }
                            })
                        }
                        #[allow(non_upper_case_globals)]
                        const _: () = {
                            static __INVENTORY: ::inventory::Node = ::inventory::Node {
                                value: &{
                                    dioxus_server::ServerFunction::new(
                                        dioxus_server::http::Method::POST,
                                        __ENDPOINT_PATH,
                                        || {
                                            dioxus_server::ServerFunction::make_handler(
                                                dioxus_server::http::Method::POST,
                                                __inner__function__,
                                            )
                                        },
                                    )
                                },
                                next: ::inventory::core::cell::UnsafeCell::new(
                                    ::inventory::core::option::Option::None,
                                ),
                            };
                            #[link_section = ".text.startup"]
                            unsafe extern "C" fn __ctor() {
                                unsafe {
                                    ::inventory::ErasedNode::submit(
                                        __INVENTORY.value,
                                        &__INVENTORY,
                                    )
                                }
                            }
                            #[used]
                            #[link_section = ".init_array"]
                            static __CTOR: unsafe extern "C" fn() = __ctor;
                        };
                        let (___sarg___0,) = dioxus_fullstack::FullstackContext::extract::<
                            (State<AppDatabase>,),
                            _,
                        >()
                            .await?;
                        return login_action(___Arg0, ___sarg___0).await;
                    }
                    #[allow(unreachable_code)]
                    {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
                /**# Handler information
- Method: `post`
- Path: `/front/logout/action`*/
                #[deny(
                    unexpected_cfgs,
                    reason = "
==========================================================================================
  Using Dioxus Server Functions requires a `server` feature flag in your `Cargo.toml`.
  Please add the following to your `Cargo.toml`:

  ```toml
  [features]
  server = [\"dioxus/server\"]
  ```

  To enable better Rust-Analyzer support, you can make `server` a default feature:
  ```toml
  [features]
  default = [\"web\", \"server\"]
  web = [\"dioxus/web\"]
  server = [\"dioxus/server\"]
  ```
==========================================================================================
        "
                )]
                async fn logout_action(
                    #[allow(unused_mut)]
                    ___Arg0: Form<()>,
                ) -> Result<Response<Body>> {
                    use dioxus_fullstack::serde as serde;
                    use dioxus_fullstack::{
                        ServerFnEncoder, ServerFnDecoder, FullstackContext,
                        ExtractRequest, EncodeRequest, RequestDecodeResult,
                        RequestDecodeErr, MakeAxumResponse, MakeAxumError,
                    };
                    #[serde(crate = "serde")]
                    struct __QueryParams__ {}
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __QueryParams__ {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private228::PhantomData<__QueryParams__>,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = __QueryParams__;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct __QueryParams__",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        _serde::__private228::Ok(__QueryParams__ {})
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "__QueryParams__",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            __QueryParams__,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for __QueryParams__ {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "__QueryParams__",
                                    false as usize,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[serde(crate = "serde")]
                    struct ___Body_Serialize___<__Ty0> {
                        ___Arg0: __Ty0,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<__Ty0> _serde::Serialize for ___Body_Serialize___<__Ty0>
                        where
                            __Ty0: _serde::Serialize,
                        {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                let mut __serde_state = _serde::Serializer::serialize_struct(
                                    __serializer,
                                    "___Body_Serialize___",
                                    false as usize + 1,
                                )?;
                                _serde::ser::SerializeStruct::serialize_field(
                                    &mut __serde_state,
                                    "___Arg0",
                                    &self.___Arg0,
                                )?;
                                _serde::ser::SerializeStruct::end(__serde_state)
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications,
                        clippy::absolute_paths,
                    )]
                    const _: () = {
                        use serde as _serde;
                        #[automatically_derived]
                        impl<'de, __Ty0> _serde::Deserialize<'de>
                        for ___Body_Serialize___<__Ty0>
                        where
                            __Ty0: _serde::Deserialize<'de>,
                        {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                #[automatically_derived]
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "___Arg0" => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private228::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"___Arg0" => _serde::__private228::Ok(__Field::__field0),
                                            _ => _serde::__private228::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private228::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, __Ty0>
                                where
                                    __Ty0: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private228::PhantomData<
                                        ___Body_Serialize___<__Ty0>,
                                    >,
                                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de, __Ty0> _serde::de::Visitor<'de>
                                for __Visitor<'de, __Ty0>
                                where
                                    __Ty0: _serde::Deserialize<'de>,
                                {
                                    type Value = ___Body_Serialize___<__Ty0>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private228::Formatter,
                                    ) -> _serde::__private228::fmt::Result {
                                        _serde::__private228::Formatter::write_str(
                                            __formatter,
                                            "struct ___Body_Serialize___",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            __Ty0,
                                        >(&mut __seq)? {
                                            _serde::__private228::Some(__value) => __value,
                                            _serde::__private228::None => {
                                                return _serde::__private228::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct ___Body_Serialize___ with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private228::Ok(___Body_Serialize___ {
                                            ___Arg0: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private228::Option<__Ty0> = _serde::__private228::None;
                                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private228::Option::is_some(&__field0) {
                                                        return _serde::__private228::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "___Arg0",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private228::Some(
                                                        _serde::de::MapAccess::next_value::<__Ty0>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private228::Some(__field0) => __field0,
                                            _serde::__private228::None => {
                                                _serde::__private228::de::missing_field("___Arg0")?
                                            }
                                        };
                                        _serde::__private228::Ok(___Body_Serialize___ {
                                            ___Arg0: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["___Arg0"];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "___Body_Serialize___",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private228::PhantomData::<
                                            ___Body_Serialize___<__Ty0>,
                                        >,
                                        lifetime: _serde::__private228::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    const __ENDPOINT_PATH: &str = ::const_format::pmr::__AssertStr {
                        x: {
                            use ::const_format::__cf_osRcTFl4A;
                            ({
                                #[doc(hidden)]
                                #[allow(unused_mut, non_snake_case)]
                                const CONCATP_NHPMWYD3NJA: &[__cf_osRcTFl4A::pmr::PArgument] = {
                                    let fmt = __cf_osRcTFl4A::pmr::FormattingFlags::NEW;
                                    &[
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("/front/logout/action")
                                            .to_pargument_display(fmt),
                                        __cf_osRcTFl4A::pmr::PConvWrapper("")
                                            .to_pargument_display(fmt),
                                    ]
                                };
                                {
                                    #[doc(hidden)]
                                    const ARR_LEN: usize = ::const_format::pmr::PArgument::calc_len(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    const CONCAT_ARR: &::const_format::pmr::LenAndArray<
                                        [u8; ARR_LEN],
                                    > = &::const_format::pmr::__priv_concatenate(
                                        CONCATP_NHPMWYD3NJA,
                                    );
                                    #[doc(hidden)]
                                    #[allow(clippy::transmute_ptr_to_ptr)]
                                    const CONCAT_STR: &str = unsafe {
                                        let slice = ::const_format::pmr::transmute::<
                                            &[u8; ARR_LEN],
                                            &[u8; CONCAT_ARR.len],
                                        >(&CONCAT_ARR.array);
                                        {
                                            let bytes: &'static [::const_format::pmr::u8] = slice;
                                            let string: &'static ::const_format::pmr::str = {
                                                ::const_format::__hidden_utils::PtrToRef {
                                                    ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                }
                                                    .reff
                                            };
                                            string
                                        }
                                    };
                                    CONCAT_STR
                                }
                            })
                        },
                    }
                        .x;
                    {
                        _ = dioxus_fullstack::assert_is_result::<
                            Result<Response<Body>>,
                        >();
                        let verify_token = (&&&&&&&&&&&&&&ServerFnEncoder::<
                            ___Body_Serialize___<Form<()>>,
                            (Form<()>,),
                        >::new())
                            .verify_can_serialize();
                        dioxus_fullstack::assert_can_encode(verify_token);
                        let decode_token = (&&&&&ServerFnDecoder::<
                            Result<Response<Body>>,
                        >::new())
                            .verify_can_deserialize();
                        dioxus_fullstack::assert_can_decode(decode_token);
                    };
                    {
                        async fn logout_action(
                            Form(()): Form<()>,
                            header: TypedHeader<Cookie>,
                        ) -> Result<Response<Body>> {
                            let save_id = header
                                .0
                                .get("save_id")
                                .map(|m| m.parse::<bool>());
                            let save_id = if let Some(Ok(save_id)) = save_id {
                                save_id
                            } else {
                                false
                            };
                            let mut response = Response::new(Body::empty());
                            let res_header = response.headers_mut();
                            for (key, _) in header.iter() {
                                if key == "username" && save_id {
                                    continue;
                                }
                                res_header
                                    .append(
                                        SET_COOKIE,
                                        HeaderValue::from_str(
                                            ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0}=; Path=/; HttpOnly; Max-Age=0;", key),
                                                    )
                                                })
                                                .as_str(),
                                        )?,
                                    );
                            }
                            res_header.append(LOCATION, HeaderValue::from_str("/")?);
                            add_no_cache_headers(res_header);
                            Ok(response)
                        }
                        #[allow(clippy::unused_unit)]
                        fn __inner__function__(
                            ___state: dioxus_server::axum::extract::State<
                                FullstackContext,
                            >,
                            ___request: dioxus_server::axum::extract::Request,
                        ) -> std::pin::Pin<
                            Box<
                                dyn std::future::Future<
                                    Output = dioxus_server::axum::response::Response,
                                >,
                            >,
                        > {
                            Box::pin(async move {
                                match (&&&&&&&&&&&&&&ServerFnEncoder::<
                                    ___Body_Serialize___<Form<()>>,
                                    (Form<()>,),
                                >::new())
                                    .extract_axum(
                                        ___state.0,
                                        ___request,
                                        |data| { (data.___Arg0,) },
                                    )
                                    .await
                                {
                                    Ok(
                                        (
                                            (___Arg0,),
                                            (
                                                dioxus_server::axum::extract::Path(()),
                                                dioxus_fullstack::payloads::Query(__QueryParams__ {}),
                                                ___sarg___0,
                                            ),
                                        ),
                                    ) => {
                                        let res = logout_action(___Arg0, ___sarg___0).await;
                                        let encoded = (&&&&&&ServerFnDecoder::<
                                            Result<Response<Body>>,
                                        >::new())
                                            .make_axum_response(res);
                                        (&&&&&ServerFnDecoder::<Result<Response<Body>>>::new())
                                            .make_axum_error(encoded)
                                    }
                                    Err(res) => res,
                                }
                            })
                        }
                        #[allow(non_upper_case_globals)]
                        const _: () = {
                            static __INVENTORY: ::inventory::Node = ::inventory::Node {
                                value: &{
                                    dioxus_server::ServerFunction::new(
                                        dioxus_server::http::Method::POST,
                                        __ENDPOINT_PATH,
                                        || {
                                            dioxus_server::ServerFunction::make_handler(
                                                dioxus_server::http::Method::POST,
                                                __inner__function__,
                                            )
                                        },
                                    )
                                },
                                next: ::inventory::core::cell::UnsafeCell::new(
                                    ::inventory::core::option::Option::None,
                                ),
                            };
                            #[link_section = ".text.startup"]
                            unsafe extern "C" fn __ctor() {
                                unsafe {
                                    ::inventory::ErasedNode::submit(
                                        __INVENTORY.value,
                                        &__INVENTORY,
                                    )
                                }
                            }
                            #[used]
                            #[link_section = ".init_array"]
                            static __CTOR: unsafe extern "C" fn() = __ctor;
                        };
                        let (___sarg___0,) = dioxus_fullstack::FullstackContext::extract::<
                            (TypedHeader<Cookie>,),
                            _,
                        >()
                            .await?;
                        return logout_action(___Arg0, ___sarg___0).await;
                    }
                    #[allow(unreachable_code)]
                    {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
        }
        pub mod home {
            use dioxus::prelude::*;
            use crate::front::page::component::login::Login;
            #[allow(non_snake_case)]
            pub fn Home() -> Element {
                {
                    {
                        dioxus_core::Element::Ok({
                            fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                                static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                                    dioxus_core::internal::HotReloadedTemplate,
                                > = ::std::sync::OnceLock::new();
                                if __ORIGINAL_TEMPLATE.get().is_none() {
                                    _ = __ORIGINAL_TEMPLATE
                                        .set(
                                            dioxus_core::internal::HotReloadedTemplate::new(
                                                None,
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        dioxus_core::internal::HotReloadDynamicNode::Dynamic(0usize),
                                                    ]),
                                                ),
                                                ::alloc::vec::Vec::new(),
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        dioxus_core::internal::HotReloadLiteral::Bool(false),
                                                    ]),
                                                ),
                                                __TEMPLATE_ROOTS,
                                            ),
                                        );
                                }
                                __ORIGINAL_TEMPLATE.get().unwrap()
                            }
                            let __template_read = {
                                use dioxus_signals::ReadableExt;
                                static __NORMALIZED_FILE: &'static str = {
                                    const PATH: &str = ::const_format::pmr::__AssertStr {
                                        x: {
                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                    "fullstack/src/front/page/home.rs",
                                                    "\\\\",
                                                    "/",
                                                )
                                                .conv();
                                            {
                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                const OS: &::const_format::pmr::str = unsafe {
                                                    {
                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                        let string: &'static ::const_format::pmr::str = {
                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                            }
                                                                .reff
                                                        };
                                                        string
                                                    }
                                                };
                                                OS
                                            }
                                        },
                                    }
                                        .x;
                                    ::const_format::pmr::__AssertStr {
                                        x: {
                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                    PATH,
                                                    '\\',
                                                    "/",
                                                )
                                                .conv();
                                            {
                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                const OS: &::const_format::pmr::str = unsafe {
                                                    {
                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                        let string: &'static ::const_format::pmr::str = {
                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                            }
                                                                .reff
                                                        };
                                                        string
                                                    }
                                                };
                                                OS
                                            }
                                        },
                                    }
                                        .x
                                };
                                static __TEMPLATE: dioxus_signals::GlobalSignal<
                                    Option<dioxus_core::internal::HotReloadedTemplate>,
                                > = dioxus_signals::GlobalSignal::with_location(
                                    || None::<dioxus_core::internal::HotReloadedTemplate>,
                                    __NORMALIZED_FILE,
                                    7u32,
                                    5u32,
                                    0usize,
                                );
                                dioxus_core::Runtime::try_current()
                                    .map(|_| __TEMPLATE.read())
                            };
                            let __template_read = match __template_read
                                .as_ref()
                                .map(|__template_read| __template_read.as_ref())
                            {
                                Some(Some(__template_read)) => &__template_read,
                                _ => __original_template(),
                            };
                            let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                                ::alloc::vec::Vec::new(),
                            );
                            let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                dioxus_core::DynamicNode::Component({
                                    use dioxus_core::Properties;
                                    let __comp = ({
                                        dioxus_core::fc_to_builder(Login)
                                            .is_login({
                                                {
                                                    __dynamic_literal_pool
                                                        .component_property(0usize, &*__template_read, false)
                                                }
                                            })
                                            .build()
                                    })
                                        .into_vcomponent(Login);
                                    __comp
                                }),
                            ];
                            let __dynamic_attributes: [Box<
                                [dioxus_core::Attribute],
                            >; 0usize] = [];
                            #[doc(hidden)]
                            static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                dioxus_core::TemplateNode::Dynamic {
                                    id: 0usize,
                                },
                                {
                                    dioxus_core::TemplateNode::Element {
                                        tag: dioxus_elements::elements::h1::TAG_NAME,
                                        namespace: dioxus_elements::h1::NAME_SPACE,
                                        attrs: &[],
                                        children: &[
                                            dioxus_core::TemplateNode::Text {
                                                text: "Hello World",
                                            },
                                        ],
                                    }
                                },
                            ];
                            {
                                let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                                    Vec::from(__dynamic_nodes),
                                    Vec::from(__dynamic_attributes),
                                    __dynamic_literal_pool,
                                );
                                __dynamic_value_pool.render_with(__template_read)
                            }
                        })
                    }
                }
            }
            #[allow(non_snake_case)]
            #[doc(hidden)]
            mod Home_completions {
                #[doc(hidden)]
                #[allow(non_camel_case_types)]
                /// This enum is generated to help autocomplete the braces after the component. It does nothing
                pub enum Component {
                    Home {},
                }
            }
            #[allow(unused)]
            pub use Home_completions::Component::Home;
        }
    }
    pub mod util {
        use dioxus::fullstack::http::{HeaderMap, HeaderValue};
        use reqwest::header::{CACHE_CONTROL, EXPIRES, PRAGMA};
        pub fn add_no_cache_headers(headers: &mut HeaderMap) {
            headers
                .insert(
                    CACHE_CONTROL,
                    HeaderValue::from_static("no-cache, no-store, must-revalidate"),
                );
            headers.insert(PRAGMA, HeaderValue::from_static("no-cache"));
            headers.insert(EXPIRES, HeaderValue::from_static("0"));
        }
    }
    use crate::front::page::home::Home;
    use crate::resources::style::TACIT;
    use dioxus::prelude::*;
    #[rustfmt::skip]
    enum Route {
        #[route("/")]
        Home {},
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Route {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Home")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Route {
        #[inline]
        fn clone(&self) -> Route {
            Route::Home {}
        }
    }
    const _: () = {
        /// An error that can occur when trying to parse the route variant `/`.
        #[allow(non_camel_case_types)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum HomeParseError {
            /// An error that can occur when extra segments are provided after the route.
            ExtraSegments(String),
            /// An error that can occur when trying to parse the static segment '/'.
            StaticSegment0ParseError(String),
        }
        impl ::std::fmt::Debug for HomeParseError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("{0}({1})", "HomeParseError", self))
            }
        }
        impl ::std::fmt::Display for HomeParseError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                match self {
                    Self::ExtraSegments(segments) => {
                        f.write_fmt(
                            format_args!(
                                "Found additional trailing segments: {0}",
                                segments,
                            ),
                        )?
                    }
                    Self::StaticSegment0ParseError(found) => {
                        f.write_fmt(
                            format_args!(
                                "Static segment \'{0}\' did not match instead found \'{1}\'",
                                "",
                                found,
                            ),
                        )?
                    }
                }
                Ok(())
            }
        }
        /// An error that can occur when trying to parse the route enum [`Route`].
        #[allow(non_camel_case_types)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum RouteMatchError {
            /// An error that can occur when trying to parse the route [`Route::Home`] ('/').
            Home(HomeParseError),
        }
        impl ::std::fmt::Debug for RouteMatchError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("{0}({1})", "RouteMatchError", self))
            }
        }
        impl ::std::fmt::Display for RouteMatchError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                match self {
                    Self::Home(err) => {
                        f.write_fmt(
                            format_args!(
                                "Route \'{0}\' (\'{1}\') did not match:\n{2}",
                                "Home",
                                "/",
                                err,
                            ),
                        )?
                    }
                }
                Ok(())
            }
        }
        impl std::fmt::Display for Route {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                #[allow(unused)]
                match self {
                    Self::Home {} => {
                        f.write_fmt(format_args!("/{0}", ""))?;
                    }
                }
                Ok(())
            }
        }
        impl dioxus_router::routable::Routable for Route
        where
            Self: Clone,
        {
            const SITE_MAP: &'static [dioxus_router::routable::SiteMapSegment] = &[
                dioxus_router::routable::SiteMapSegment {
                    segment_type: dioxus_router::routable::SegmentType::Static(""),
                    children: &[],
                },
            ];
            fn render(&self, level: usize) -> dioxus_core::Element {
                let myself = self.clone();
                match (level, myself) {
                    #[allow(unused)]
                    (0usize, Self::Home {}) => {
                        dioxus_core::Element::Ok({
                            fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                                static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                                    dioxus_core::internal::HotReloadedTemplate,
                                > = ::std::sync::OnceLock::new();
                                if __ORIGINAL_TEMPLATE.get().is_none() {
                                    _ = __ORIGINAL_TEMPLATE
                                        .set(
                                            dioxus_core::internal::HotReloadedTemplate::new(
                                                None,
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        dioxus_core::internal::HotReloadDynamicNode::Dynamic(0usize),
                                                    ]),
                                                ),
                                                ::alloc::vec::Vec::new(),
                                                ::alloc::vec::Vec::new(),
                                                __TEMPLATE_ROOTS,
                                            ),
                                        );
                                }
                                __ORIGINAL_TEMPLATE.get().unwrap()
                            }
                            let __template_read = {
                                use dioxus_signals::ReadableExt;
                                static __NORMALIZED_FILE: &'static str = {
                                    const PATH: &str = ::const_format::pmr::__AssertStr {
                                        x: {
                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                    "fullstack/src/front/mod.rs",
                                                    "\\\\",
                                                    "/",
                                                )
                                                .conv();
                                            {
                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                const OS: &::const_format::pmr::str = unsafe {
                                                    {
                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                        let string: &'static ::const_format::pmr::str = {
                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                            }
                                                                .reff
                                                        };
                                                        string
                                                    }
                                                };
                                                OS
                                            }
                                        },
                                    }
                                        .x;
                                    ::const_format::pmr::__AssertStr {
                                        x: {
                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                    PATH,
                                                    '\\',
                                                    "/",
                                                )
                                                .conv();
                                            {
                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                const OS: &::const_format::pmr::str = unsafe {
                                                    {
                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                        let string: &'static ::const_format::pmr::str = {
                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                            }
                                                                .reff
                                                        };
                                                        string
                                                    }
                                                };
                                                OS
                                            }
                                        },
                                    }
                                        .x
                                };
                                static __TEMPLATE: dioxus_signals::GlobalSignal<
                                    Option<dioxus_core::internal::HotReloadedTemplate>,
                                > = dioxus_signals::GlobalSignal::with_location(
                                    || None::<dioxus_core::internal::HotReloadedTemplate>,
                                    __NORMALIZED_FILE,
                                    8u32,
                                    24u32,
                                    0usize,
                                );
                                dioxus_core::Runtime::try_current()
                                    .map(|_| __TEMPLATE.read())
                            };
                            let __template_read = match __template_read
                                .as_ref()
                                .map(|__template_read| __template_read.as_ref())
                            {
                                Some(Some(__template_read)) => &__template_read,
                                _ => __original_template(),
                            };
                            let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                                ::alloc::vec::Vec::new(),
                            );
                            let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                dioxus_core::DynamicNode::Component({
                                    use dioxus_core::Properties;
                                    let __comp = ({ dioxus_core::fc_to_builder(Home).build() })
                                        .into_vcomponent(Home);
                                    __comp
                                }),
                            ];
                            let __dynamic_attributes: [Box<
                                [dioxus_core::Attribute],
                            >; 0usize] = [];
                            #[doc(hidden)]
                            static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                dioxus_core::TemplateNode::Dynamic {
                                    id: 0usize,
                                },
                            ];
                            {
                                let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                                    Vec::from(__dynamic_nodes),
                                    Vec::from(__dynamic_attributes),
                                    __dynamic_literal_pool,
                                );
                                __dynamic_value_pool.render_with(__template_read)
                            }
                        })
                    }
                    _ => VNode::empty(),
                }
            }
        }
        impl<'a> ::core::convert::TryFrom<&'a str> for Route {
            type Error = <Self as ::std::str::FromStr>::Err;
            fn try_from(s: &'a str) -> ::std::result::Result<Self, Self::Error> {
                s.parse()
            }
        }
        impl ::std::str::FromStr for Route {
            type Err = dioxus_router::routable::RouteParseError<RouteMatchError>;
            fn from_str(s: &str) -> ::std::result::Result<Self, Self::Err> {
                let route = s;
                let (route, hash) = route.split_once('#').unwrap_or((route, ""));
                let (route, query) = route.split_once('?').unwrap_or((route, ""));
                let route = route.strip_suffix('/').unwrap_or(route);
                let query = dioxus_router::exports::percent_encoding::percent_decode_str(
                        query,
                    )
                    .decode_utf8()
                    .unwrap_or(query.into());
                let hash = dioxus_router::exports::percent_encoding::percent_decode_str(
                        hash,
                    )
                    .decode_utf8()
                    .unwrap_or(hash.into());
                let mut segments = route
                    .split('/')
                    .map(|s| {
                        dioxus_router::exports::percent_encoding::percent_decode_str(s)
                            .decode_utf8()
                            .unwrap_or(s.into())
                    });
                if s.starts_with('/') {
                    let _ = segments.next();
                } else {
                    return Err(dioxus_router::routable::RouteParseError {
                        attempted_routes: Vec::new(),
                    });
                }
                let mut errors = Vec::new();
                {
                    let remaining_segments = segments.clone();
                    let mut segments_clone = segments.clone();
                    let next_segment = segments_clone.next();
                    if next_segment.is_none() {
                        return Ok(Route::Home {});
                    } else {
                        let mut trailing = String::new();
                        for seg in remaining_segments {
                            trailing += &*seg;
                            trailing += "/";
                        }
                        trailing.pop();
                        errors
                            .push(
                                RouteMatchError::Home(
                                    HomeParseError::ExtraSegments(trailing),
                                ),
                            )
                    }
                }
                Err(dioxus_router::routable::RouteParseError {
                    attempted_routes: errors,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Route {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Route {
        #[inline]
        fn eq(&self, other: &Route) -> bool {
            true
        }
    }
    #[allow(non_snake_case)]
    pub fn app() -> Element {
        {
            {
                dioxus_core::Element::Ok({
                    fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                        static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                            dioxus_core::internal::HotReloadedTemplate,
                        > = ::std::sync::OnceLock::new();
                        if __ORIGINAL_TEMPLATE.get().is_none() {
                            _ = __ORIGINAL_TEMPLATE
                                .set(
                                    dioxus_core::internal::HotReloadedTemplate::new(
                                        None,
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                dioxus_core::internal::HotReloadDynamicNode::Dynamic(
                                                    0usize,
                                                ),
                                                dioxus_core::internal::HotReloadDynamicNode::Dynamic(
                                                    1usize,
                                                ),
                                                dioxus_core::internal::HotReloadDynamicNode::Dynamic(2usize),
                                            ]),
                                        ),
                                        ::alloc::vec::Vec::new(),
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                dioxus_core::internal::HotReloadLiteral::Fmted(
                                                    dioxus_core::internal::FmtedSegments::new(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                dioxus_core::internal::FmtSegment::Literal {
                                                                    value: "stylesheet",
                                                                },
                                                            ]),
                                                        ),
                                                    ),
                                                ),
                                            ]),
                                        ),
                                        __TEMPLATE_ROOTS,
                                    ),
                                );
                        }
                        __ORIGINAL_TEMPLATE.get().unwrap()
                    }
                    let __template_read = {
                        use dioxus_signals::ReadableExt;
                        static __NORMALIZED_FILE: &'static str = {
                            const PATH: &str = ::const_format::pmr::__AssertStr {
                                x: {
                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                            "fullstack/src/front/mod.rs",
                                            "\\\\",
                                            "/",
                                        )
                                        .conv();
                                    {
                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                        const OS: &::const_format::pmr::str = unsafe {
                                            {
                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                let string: &'static ::const_format::pmr::str = {
                                                    ::const_format::__hidden_utils::PtrToRef {
                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                    }
                                                        .reff
                                                };
                                                string
                                            }
                                        };
                                        OS
                                    }
                                },
                            }
                                .x;
                            ::const_format::pmr::__AssertStr {
                                x: {
                                    const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                            PATH,
                                            '\\',
                                            "/",
                                        )
                                        .conv();
                                    {
                                        const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                            .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                        const OS: &::const_format::pmr::str = unsafe {
                                            {
                                                let bytes: &'static [::const_format::pmr::u8] = OB;
                                                let string: &'static ::const_format::pmr::str = {
                                                    ::const_format::__hidden_utils::PtrToRef {
                                                        ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                    }
                                                        .reff
                                                };
                                                string
                                            }
                                        };
                                        OS
                                    }
                                },
                            }
                                .x
                        };
                        static __TEMPLATE: dioxus_signals::GlobalSignal<
                            Option<dioxus_core::internal::HotReloadedTemplate>,
                        > = dioxus_signals::GlobalSignal::with_location(
                            || None::<dioxus_core::internal::HotReloadedTemplate>,
                            __NORMALIZED_FILE,
                            16u32,
                            5u32,
                            0usize,
                        );
                        dioxus_core::Runtime::try_current().map(|_| __TEMPLATE.read())
                    };
                    let __template_read = match __template_read
                        .as_ref()
                        .map(|__template_read| __template_read.as_ref())
                    {
                        Some(Some(__template_read)) => &__template_read,
                        _ => __original_template(),
                    };
                    let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                        ::alloc::vec::Vec::new(),
                    );
                    let __dynamic_nodes: [dioxus_core::DynamicNode; 3usize] = [
                        dioxus_core::DynamicNode::Component({
                            use dioxus_core::Properties;
                            let __comp = ({
                                dioxus_core::fc_to_builder(document::Title)
                                    .children(
                                        dioxus_core::Element::Ok({
                                            fn __original_template() -> &'static dioxus_core::internal::HotReloadedTemplate {
                                                static __ORIGINAL_TEMPLATE: ::std::sync::OnceLock<
                                                    dioxus_core::internal::HotReloadedTemplate,
                                                > = ::std::sync::OnceLock::new();
                                                if __ORIGINAL_TEMPLATE.get().is_none() {
                                                    _ = __ORIGINAL_TEMPLATE
                                                        .set(
                                                            dioxus_core::internal::HotReloadedTemplate::new(
                                                                None,
                                                                ::alloc::vec::Vec::new(),
                                                                ::alloc::vec::Vec::new(),
                                                                ::alloc::vec::Vec::new(),
                                                                __TEMPLATE_ROOTS,
                                                            ),
                                                        );
                                                }
                                                __ORIGINAL_TEMPLATE.get().unwrap()
                                            }
                                            let __template_read = {
                                                use dioxus_signals::ReadableExt;
                                                static __NORMALIZED_FILE: &'static str = {
                                                    const PATH: &str = ::const_format::pmr::__AssertStr {
                                                        x: {
                                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                                    "fullstack/src/front/mod.rs",
                                                                    "\\\\",
                                                                    "/",
                                                                )
                                                                .conv();
                                                            {
                                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                                const OS: &::const_format::pmr::str = unsafe {
                                                                    {
                                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                        let string: &'static ::const_format::pmr::str = {
                                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                            }
                                                                                .reff
                                                                        };
                                                                        string
                                                                    }
                                                                };
                                                                OS
                                                            }
                                                        },
                                                    }
                                                        .x;
                                                    ::const_format::pmr::__AssertStr {
                                                        x: {
                                                            const ARGS_OSRCTFL4A: ::const_format::__str_methods::ReplaceInput = ::const_format::__str_methods::ReplaceInputConv(
                                                                    PATH,
                                                                    '\\',
                                                                    "/",
                                                                )
                                                                .conv();
                                                            {
                                                                const OB: &[::const_format::pmr::u8; ARGS_OSRCTFL4A
                                                                    .replace_length()] = &ARGS_OSRCTFL4A.replace();
                                                                const OS: &::const_format::pmr::str = unsafe {
                                                                    {
                                                                        let bytes: &'static [::const_format::pmr::u8] = OB;
                                                                        let string: &'static ::const_format::pmr::str = {
                                                                            ::const_format::__hidden_utils::PtrToRef {
                                                                                ptr: bytes as *const [::const_format::pmr::u8] as *const str,
                                                                            }
                                                                                .reff
                                                                        };
                                                                        string
                                                                    }
                                                                };
                                                                OS
                                                            }
                                                        },
                                                    }
                                                        .x
                                                };
                                                static __TEMPLATE: dioxus_signals::GlobalSignal<
                                                    Option<dioxus_core::internal::HotReloadedTemplate>,
                                                > = dioxus_signals::GlobalSignal::with_location(
                                                    || None::<dioxus_core::internal::HotReloadedTemplate>,
                                                    __NORMALIZED_FILE,
                                                    16u32,
                                                    5u32,
                                                    1usize,
                                                );
                                                dioxus_core::Runtime::try_current()
                                                    .map(|_| __TEMPLATE.read())
                                            };
                                            let __template_read = match __template_read
                                                .as_ref()
                                                .map(|__template_read| __template_read.as_ref())
                                            {
                                                Some(Some(__template_read)) => &__template_read,
                                                _ => __original_template(),
                                            };
                                            let mut __dynamic_literal_pool = dioxus_core::internal::DynamicLiteralPool::new(
                                                ::alloc::vec::Vec::new(),
                                            );
                                            let __dynamic_nodes: [dioxus_core::DynamicNode; 0usize] = [];
                                            let __dynamic_attributes: [Box<
                                                [dioxus_core::Attribute],
                                            >; 0usize] = [];
                                            #[doc(hidden)]
                                            static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                dioxus_core::TemplateNode::Text {
                                                    text: "Dolto's Blog",
                                                },
                                            ];
                                            {
                                                let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                                                    Vec::from(__dynamic_nodes),
                                                    Vec::from(__dynamic_attributes),
                                                    __dynamic_literal_pool,
                                                );
                                                __dynamic_value_pool.render_with(__template_read)
                                            }
                                        }),
                                    )
                                    .build()
                            })
                                .into_vcomponent(document::Title);
                            __comp
                        }),
                        dioxus_core::DynamicNode::Component({
                            use dioxus_core::Properties;
                            let __comp = ({
                                dioxus_core::fc_to_builder(document::Link)
                                    .rel({
                                        {
                                            __dynamic_literal_pool
                                                .component_property(0usize, &*__template_read, "stylesheet")
                                        }
                                    })
                                    .href(TACIT)
                                    .build()
                            })
                                .into_vcomponent(document::Link);
                            __comp
                        }),
                        dioxus_core::DynamicNode::Component({
                            use dioxus_core::Properties;
                            let __comp = ({
                                dioxus_core::fc_to_builder(Router::<Route>).build()
                            })
                                .into_vcomponent(Router::<Route>);
                            __comp
                        }),
                    ];
                    let __dynamic_attributes: [Box<[dioxus_core::Attribute]>; 0usize] = [];
                    #[doc(hidden)]
                    static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                        dioxus_core::TemplateNode::Dynamic {
                            id: 0usize,
                        },
                        dioxus_core::TemplateNode::Dynamic {
                            id: 1usize,
                        },
                        dioxus_core::TemplateNode::Dynamic {
                            id: 2usize,
                        },
                    ];
                    {
                        let mut __dynamic_value_pool = dioxus_core::internal::DynamicValuePool::new(
                            Vec::from(__dynamic_nodes),
                            Vec::from(__dynamic_attributes),
                            __dynamic_literal_pool,
                        );
                        __dynamic_value_pool.render_with(__template_read)
                    }
                })
            }
        }
    }
    #[allow(non_snake_case)]
    #[doc(hidden)]
    mod app_completions {
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        /// This enum is generated to help autocomplete the braces after the component. It does nothing
        pub enum Component {
            app {},
        }
    }
    #[allow(unused)]
    pub use app_completions::Component::app;
}
pub mod middle {
    use std::time::Duration;
    use axum::{Router, middleware};
    use reqwest::{StatusCode, header::AUTHORIZATION};
    use tower::ServiceBuilder;
    use tower_http::{
        compression::CompressionLayer,
        sensitive_headers::SetSensitiveRequestHeadersLayer, timeout::TimeoutLayer,
        trace::TraceLayer,
    };
    use crate::utils::jwt::authenticate;
    pub fn init_middel_ware(
        dont_need_auth_route: Router,
        need_auth_route: Router,
    ) -> Router {
        let router = auth_middel_ware(dont_need_auth_route, need_auth_route);
        let middleware = ServiceBuilder::new()
            .concurrency_limit(32)
            .layer(
                SetSensitiveRequestHeadersLayer::new(
                    <[_]>::into_vec(::alloc::boxed::box_new([AUTHORIZATION])),
                ),
            )
            .layer(
                TimeoutLayer::with_status_code(
                    StatusCode::REQUEST_TIMEOUT,
                    Duration::from_secs(3),
                ),
            )
            .layer(CompressionLayer::new());
        router.layer(middleware).layer(TraceLayer::new_for_http())
    }
    fn auth_middel_ware(
        dont_need_auth_route: Router,
        need_auth_route: Router,
    ) -> Router {
        need_auth_route
            .route_layer(middleware::from_fn(authenticate))
            .merge(dont_need_auth_route)
    }
    pub async fn time_out_test() -> String {
        tokio::time::sleep(Duration::from_secs(5)).await;
        "Why?".to_string()
    }
}
pub mod resources {
    pub mod dto {
        pub mod fullstack_extension {
            use crate::{
                database, router::hello::state::{HelloState, get_hello_state},
                utils::errors::AppError, ws::{self, state::WsState},
            };
            use axum::extract::FromRef;
            use sea_orm::DatabaseConnection;
            use state_fullstack_context_macro::FromFullstackContextRef;
            pub struct AppDatabase(pub DatabaseConnection);
            #[automatically_derived]
            impl ::core::clone::Clone for AppDatabase {
                #[inline]
                fn clone(&self) -> AppDatabase {
                    AppDatabase(::core::clone::Clone::clone(&self.0))
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<AppDatabase> for DatabaseConnection {
                fn from_ref(state: &AppDatabase) -> Self {
                    state.0.clone()
                }
            }
            pub struct AppExtension {
                pub db: AppDatabase,
                pub ws: WsState,
                pub hello: HelloState,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for AppExtension {
                #[inline]
                fn clone(&self) -> AppExtension {
                    AppExtension {
                        db: ::core::clone::Clone::clone(&self.db),
                        ws: ::core::clone::Clone::clone(&self.ws),
                        hello: ::core::clone::Clone::clone(&self.hello),
                    }
                }
            }
            impl axum::extract::FromRef<dioxus::fullstack::FullstackContext>
            for AppExtension {
                fn from_ref(state: &dioxus::fullstack::FullstackContext) -> Self {
                    state.extension::<AppExtension>().unwrap().clone()
                }
            }
            impl axum::extract::FromRef<dioxus::fullstack::FullstackContext>
            for AppDatabase {
                fn from_ref(state: &dioxus::fullstack::FullstackContext) -> Self {
                    let p = state
                        .extension::<AppExtension>()
                        .expect(
                            "This Struct field must differnt type about other filed!, and most be a new type pattern",
                        );
                    p.db.clone()
                }
            }
            impl axum::extract::FromRef<dioxus::fullstack::FullstackContext>
            for WsState {
                fn from_ref(state: &dioxus::fullstack::FullstackContext) -> Self {
                    let p = state
                        .extension::<AppExtension>()
                        .expect(
                            "This Struct field must differnt type about other filed!, and most be a new type pattern",
                        );
                    p.ws.clone()
                }
            }
            impl axum::extract::FromRef<dioxus::fullstack::FullstackContext>
            for HelloState {
                fn from_ref(state: &dioxus::fullstack::FullstackContext) -> Self {
                    let p = state
                        .extension::<AppExtension>()
                        .expect(
                            "This Struct field must differnt type about other filed!, and most be a new type pattern",
                        );
                    p.hello.clone()
                }
            }
            impl AppExtension {
                pub async fn init() -> Result<Self, AppError> {
                    let db = AppDatabase(database::init_db().await?);
                    Ok(AppExtension {
                        ws: ws::state::init_state(),
                        hello: get_hello_state(db.0.clone()),
                        db,
                    })
                }
            }
        }
        pub mod user {
            use serde::{Deserialize, Serialize};
            pub struct UserDTO {
                pub id: i32,
                pub username: String,
                pub password: String,
            }
            impl utoipa::__dev::ComposeSchema for UserDTO {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "id",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::Integer,
                                        ),
                                    )
                                    .format(
                                        Some(
                                            utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                utoipa::openapi::schema::KnownFormat::Int32,
                                            ),
                                        ),
                                    ),
                            )
                            .required("id");
                        object = object
                            .property(
                                "username",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("username");
                        object = object
                            .property(
                                "password",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("password");
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for UserDTO {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("UserDTO")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas.extend([]);
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserDTO {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserDTO",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "password",
                            &self.password,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserDTO {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private228::Ok(__Field::__field0),
                                    "username" => _serde::__private228::Ok(__Field::__field1),
                                    "password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private228::Ok(__Field::__field0),
                                    b"username" => _serde::__private228::Ok(__Field::__field1),
                                    b"password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<UserDTO>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserDTO;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct UserDTO",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserDTO with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UserDTO with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UserDTO with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(UserDTO {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("password")?
                                    }
                                };
                                _serde::__private228::Ok(UserDTO {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "username",
                            "password",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserDTO",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<UserDTO>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            impl From<crate::resources::entities::users::Model> for UserDTO {
                fn from(value: crate::resources::entities::users::Model) -> Self {
                    UserDTO {
                        id: value.id,
                        username: value.username,
                        password: value.password,
                    }
                }
            }
            pub struct UpsertUser {
                pub id: Option<i32>,
                pub username: Option<String>,
                #[into_params(ignore)]
                pub password: Option<String>,
            }
            impl utoipa::__dev::ComposeSchema for UpsertUser {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "id",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type({
                                        use std::iter::FromIterator;
                                        utoipa::openapi::schema::SchemaType::from_iter([
                                            utoipa::openapi::schema::Type::Integer,
                                            utoipa::openapi::schema::Type::Null,
                                        ])
                                    })
                                    .format(
                                        Some(
                                            utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                utoipa::openapi::schema::KnownFormat::Int32,
                                            ),
                                        ),
                                    ),
                            );
                        object = object
                            .property(
                                "username",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type({
                                        use std::iter::FromIterator;
                                        utoipa::openapi::schema::SchemaType::from_iter([
                                            utoipa::openapi::schema::Type::String,
                                            utoipa::openapi::schema::Type::Null,
                                        ])
                                    }),
                            );
                        object = object
                            .property(
                                "password",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type({
                                        use std::iter::FromIterator;
                                        utoipa::openapi::schema::SchemaType::from_iter([
                                            utoipa::openapi::schema::Type::String,
                                            utoipa::openapi::schema::Type::Null,
                                        ])
                                    }),
                            );
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for UpsertUser {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("UpsertUser")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas.extend([]);
                }
            }
            impl utoipa::IntoParams for UpsertUser {
                fn into_params(
                    parameter_in_provider: impl Fn(
                    ) -> Option<utoipa::openapi::path::ParameterIn>,
                ) -> Vec<utoipa::openapi::path::Parameter> {
                    [
                        Some(
                            utoipa::openapi::path::ParameterBuilder::new()
                                .name("id")
                                .parameter_in(parameter_in_provider().unwrap_or_default())
                                .required(utoipa::openapi::Required::False)
                                .schema(
                                    Some(
                                        utoipa::openapi::ObjectBuilder::new()
                                            .schema_type({
                                                use std::iter::FromIterator;
                                                utoipa::openapi::schema::SchemaType::from_iter([
                                                    utoipa::openapi::schema::Type::Integer,
                                                    utoipa::openapi::schema::Type::Null,
                                                ])
                                            })
                                            .format(
                                                Some(
                                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                        utoipa::openapi::schema::KnownFormat::Int32,
                                                    ),
                                                ),
                                            ),
                                    ),
                                )
                                .build(),
                        ),
                        Some(
                            utoipa::openapi::path::ParameterBuilder::new()
                                .name("username")
                                .parameter_in(parameter_in_provider().unwrap_or_default())
                                .required(utoipa::openapi::Required::False)
                                .schema(
                                    Some(
                                        utoipa::openapi::ObjectBuilder::new()
                                            .schema_type({
                                                use std::iter::FromIterator;
                                                utoipa::openapi::schema::SchemaType::from_iter([
                                                    utoipa::openapi::schema::Type::String,
                                                    utoipa::openapi::schema::Type::Null,
                                                ])
                                            }),
                                    ),
                                )
                                .build(),
                        ),
                        Some(
                            utoipa::openapi::path::ParameterBuilder::new()
                                .name("password")
                                .parameter_in(parameter_in_provider().unwrap_or_default())
                                .required(utoipa::openapi::Required::False)
                                .schema(
                                    Some(
                                        utoipa::openapi::ObjectBuilder::new()
                                            .schema_type({
                                                use std::iter::FromIterator;
                                                utoipa::openapi::schema::SchemaType::from_iter([
                                                    utoipa::openapi::schema::Type::String,
                                                    utoipa::openapi::schema::Type::Null,
                                                ])
                                            }),
                                    ),
                                )
                                .build(),
                        ),
                    ]
                        .into_iter()
                        .filter(Option::is_some)
                        .flatten()
                        .collect()
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpsertUser {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private228::Ok(__Field::__field0),
                                    "username" => _serde::__private228::Ok(__Field::__field1),
                                    "password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private228::Ok(__Field::__field0),
                                    b"username" => _serde::__private228::Ok(__Field::__field1),
                                    b"password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<UpsertUser>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpsertUser;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct UpsertUser",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<i32>,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpsertUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpsertUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpsertUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(UpsertUser {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<
                                    Option<i32>,
                                > = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<
                                    Option<String>,
                                > = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<
                                    Option<String>,
                                > = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<i32>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("password")?
                                    }
                                };
                                _serde::__private228::Ok(UpsertUser {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "username",
                            "password",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpsertUser",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<UpsertUser>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub struct ReadUser {
                pub id: i32,
                pub username: String,
            }
            impl utoipa::__dev::ComposeSchema for ReadUser {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "id",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::Integer,
                                        ),
                                    )
                                    .format(
                                        Some(
                                            utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                utoipa::openapi::schema::KnownFormat::Int32,
                                            ),
                                        ),
                                    ),
                            )
                            .required("id");
                        object = object
                            .property(
                                "username",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("username");
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for ReadUser {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("ReadUser")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas.extend([]);
                }
            }
            #[automatically_derived]
            impl sea_orm::FromQueryResult for ReadUser {
                fn from_query_result(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::DbErr> {
                    Ok(Self::from_query_result_nullable(row, pre)?)
                }
                fn from_query_result_nullable(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::TryGetError> {
                    let id = match row.try_get_nullable(pre, "id") {
                        Err(v @ sea_orm::TryGetError::DbErr(_)) => {
                            return Err(v);
                        }
                        v => v,
                    };
                    let username = match row.try_get_nullable(pre, "username") {
                        Err(v @ sea_orm::TryGetError::DbErr(_)) => {
                            return Err(v);
                        }
                        v => v,
                    };
                    Ok(Self {
                        id: id?,
                        username: username?,
                    })
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ReadUser {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ReadUser",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ReadUser {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private228::Ok(__Field::__field0),
                                    "username" => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private228::Ok(__Field::__field0),
                                    b"username" => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<ReadUser>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ReadUser;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct ReadUser",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ReadUser with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ReadUser with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(ReadUser {
                                    id: __field0,
                                    username: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                _serde::__private228::Ok(ReadUser {
                                    id: __field0,
                                    username: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["id", "username"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ReadUser",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<ReadUser>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ReadUser {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ReadUser",
                        "id",
                        &self.id,
                        "username",
                        &&self.username,
                    )
                }
            }
            pub struct ReqUser {
                pub username: String,
                pub password: String,
                pub save_id: Option<bool>,
            }
            impl utoipa::__dev::ComposeSchema for ReqUser {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "username",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("username");
                        object = object
                            .property(
                                "password",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("password");
                        object = object
                            .property(
                                "save_id",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type({
                                        use std::iter::FromIterator;
                                        utoipa::openapi::schema::SchemaType::from_iter([
                                            utoipa::openapi::schema::Type::Boolean,
                                            utoipa::openapi::schema::Type::Null,
                                        ])
                                    }),
                            );
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for ReqUser {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("ReqUser")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas.extend([]);
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ReqUser {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "username" => _serde::__private228::Ok(__Field::__field0),
                                    "password" => _serde::__private228::Ok(__Field::__field1),
                                    "save_id" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"username" => _serde::__private228::Ok(__Field::__field0),
                                    b"password" => _serde::__private228::Ok(__Field::__field1),
                                    b"save_id" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<ReqUser>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ReqUser;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct ReqUser",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ReqUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ReqUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<bool>,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ReqUser with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(ReqUser {
                                    username: __field0,
                                    password: __field1,
                                    save_id: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<
                                    Option<bool>,
                                > = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "save_id",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<bool>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("password")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("save_id")?
                                    }
                                };
                                _serde::__private228::Ok(ReqUser {
                                    username: __field0,
                                    password: __field1,
                                    save_id: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "username",
                            "password",
                            "save_id",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ReqUser",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<ReqUser>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ReqUser {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ReqUser",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "password",
                            &self.password,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "save_id",
                            &self.save_id,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ReqUser {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ReqUser",
                        "username",
                        &self.username,
                        "password",
                        &self.password,
                        "save_id",
                        &&self.save_id,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ReqUser {
                #[inline]
                fn clone(&self) -> ReqUser {
                    ReqUser {
                        username: ::core::clone::Clone::clone(&self.username),
                        password: ::core::clone::Clone::clone(&self.password),
                        save_id: ::core::clone::Clone::clone(&self.save_id),
                    }
                }
            }
            pub struct Tokens {
                pub jwt: String,
                pub refresh: String,
                pub user_info: ReadUser,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Tokens {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "jwt" => _serde::__private228::Ok(__Field::__field0),
                                    "refresh" => _serde::__private228::Ok(__Field::__field1),
                                    "user_info" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"jwt" => _serde::__private228::Ok(__Field::__field0),
                                    b"refresh" => _serde::__private228::Ok(__Field::__field1),
                                    b"user_info" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<Tokens>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Tokens;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct Tokens",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Tokens with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Tokens with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    ReadUser,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Tokens with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(Tokens {
                                    jwt: __field0,
                                    refresh: __field1,
                                    user_info: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<ReadUser> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("jwt"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "refresh",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "user_info",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<ReadUser>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("jwt")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("refresh")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("user_info")?
                                    }
                                };
                                _serde::__private228::Ok(Tokens {
                                    jwt: __field0,
                                    refresh: __field1,
                                    user_info: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "jwt",
                            "refresh",
                            "user_info",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Tokens",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<Tokens>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Tokens {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Tokens",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "jwt",
                            &self.jwt,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "refresh",
                            &self.refresh,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user_info",
                            &self.user_info,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for Tokens {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Tokens",
                        "jwt",
                        &self.jwt,
                        "refresh",
                        &self.refresh,
                        "user_info",
                        &&self.user_info,
                    )
                }
            }
            impl utoipa::__dev::ComposeSchema for Tokens {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "jwt",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("jwt");
                        object = object
                            .property(
                                "refresh",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("refresh");
                        object = object
                            .property(
                                "user_info",
                                utoipa::openapi::schema::RefBuilder::new()
                                    .ref_location_from_schema_name(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0}", <ReadUser as utoipa::ToSchema>::name()),
                                            )
                                        }),
                                    ),
                            )
                            .required("user_info");
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for Tokens {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("Tokens")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .extend([
                            (
                                String::from(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!("{0}", <ReadUser as utoipa::ToSchema>::name()),
                                        )
                                    }),
                                ),
                                <ReadUser as utoipa::PartialSchema>::schema(),
                            ),
                        ]);
                    <ReadUser as utoipa::ToSchema>::schemas(schemas);
                }
            }
            pub struct TokensUserId {
                pub jwt: String,
                pub refresh: String,
                pub username: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokensUserId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "jwt" => _serde::__private228::Ok(__Field::__field0),
                                    "refresh" => _serde::__private228::Ok(__Field::__field1),
                                    "username" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"jwt" => _serde::__private228::Ok(__Field::__field0),
                                    b"refresh" => _serde::__private228::Ok(__Field::__field1),
                                    b"username" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<TokensUserId>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokensUserId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct TokensUserId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokensUserId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TokensUserId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TokensUserId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(TokensUserId {
                                    jwt: __field0,
                                    refresh: __field1,
                                    username: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("jwt"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "refresh",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("jwt")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("refresh")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                _serde::__private228::Ok(TokensUserId {
                                    jwt: __field0,
                                    refresh: __field1,
                                    username: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "jwt",
                            "refresh",
                            "username",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokensUserId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<TokensUserId>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokensUserId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokensUserId",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "jwt",
                            &self.jwt,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "refresh",
                            &self.refresh,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl utoipa::__dev::ComposeSchema for TokensUserId {
                fn compose(
                    mut generics: Vec<
                        utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                    >,
                ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                    {
                        let mut object = utoipa::openapi::ObjectBuilder::new();
                        object = object
                            .property(
                                "jwt",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("jwt");
                        object = object
                            .property(
                                "refresh",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("refresh");
                        object = object
                            .property(
                                "username",
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            )
                            .required("username");
                        object
                    }
                        .into()
                }
            }
            impl utoipa::ToSchema for TokensUserId {
                fn name() -> std::borrow::Cow<'static, str> {
                    std::borrow::Cow::Borrowed("TokensUserId")
                }
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas.extend([]);
                }
            }
            pub struct JwtClaims {
                pub exp: u64,
                pub user_id: i32,
                pub username: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JwtClaims {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JwtClaims",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "exp",
                            &self.exp,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user_id",
                            &self.user_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for JwtClaims {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "exp" => _serde::__private228::Ok(__Field::__field0),
                                    "user_id" => _serde::__private228::Ok(__Field::__field1),
                                    "username" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"exp" => _serde::__private228::Ok(__Field::__field0),
                                    b"user_id" => _serde::__private228::Ok(__Field::__field1),
                                    b"username" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<JwtClaims>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JwtClaims;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct JwtClaims",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JwtClaims with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JwtClaims with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct JwtClaims with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(JwtClaims {
                                    exp: __field0,
                                    user_id: __field1,
                                    username: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<u64> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("exp"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "user_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("exp")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("user_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                _serde::__private228::Ok(JwtClaims {
                                    exp: __field0,
                                    user_id: __field1,
                                    username: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "exp",
                            "user_id",
                            "username",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JwtClaims",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<JwtClaims>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub struct RefreshClaims {
                pub user_id: i32,
                pub username: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RefreshClaims {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RefreshClaims",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user_id",
                            &self.user_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RefreshClaims {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "user_id" => _serde::__private228::Ok(__Field::__field0),
                                    "username" => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"user_id" => _serde::__private228::Ok(__Field::__field0),
                                    b"username" => _serde::__private228::Ok(__Field::__field1),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<RefreshClaims>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RefreshClaims;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct RefreshClaims",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RefreshClaims with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RefreshClaims with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(RefreshClaims {
                                    user_id: __field0,
                                    username: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "user_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("user_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                _serde::__private228::Ok(RefreshClaims {
                                    user_id: __field0,
                                    username: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["user_id", "username"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RefreshClaims",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<RefreshClaims>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
        }
    }
    pub mod entities {
        //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
        pub mod prelude {
            //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
            pub use super::category::Entity as Category;
            pub use super::product::Entity as Product;
            pub use super::refresh_token::Entity as RefreshToken;
            pub use super::users::Entity as Users;
        }
        pub mod category {
            //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
            use sea_orm::entity::prelude::*;
            use serde::{Deserialize, Serialize};
            #[sea_orm(table_name = "category")]
            pub struct Model {
                #[sea_orm(primary_key, auto_increment = false)]
                pub name: String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Model {
                #[inline]
                fn clone(&self) -> Model {
                    Model {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Model {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Model",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Model {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Model {
                #[inline]
                fn eq(&self, other: &Model) -> bool {
                    self.name == other.name
                }
            }
            /// Generated by sea-orm-macros
            pub enum Column {
                /// Generated by sea-orm-macros
                Name,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Column {}
            #[automatically_derived]
            impl ::core::clone::Clone for Column {
                #[inline]
                fn clone(&self) -> Column {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Column {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Name")
                }
            }
            ///An iterator over the variants of [Column]
            #[allow(missing_copy_implementations)]
            pub struct ColumnIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for ColumnIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                }
            }
            impl ColumnIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                    match idx {
                        0usize => ::core::option::Option::Some(Column::Name),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Column {
                type Iterator = ColumnIter;
                fn iter() -> ColumnIter {
                    ColumnIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ColumnIter {
                type Item = Column;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ColumnIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ColumnIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ColumnIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ColumnIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ColumnIter {}
            impl Clone for ColumnIter {
                fn clone(&self) -> ColumnIter {
                    ColumnIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl Column {
                fn default_as_str(&self) -> &str {
                    match self {
                        Self::Name => "name",
                    }
                }
            }
            #[automatically_derived]
            impl std::str::FromStr for Column {
                type Err = sea_orm::ColumnFromStrErr;
                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    match s {
                        "name" | "name" | "name" => Ok(Column::Name),
                        _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for Column {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Column {
                fn as_str(&self) -> &str {
                    self.default_as_str()
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::ColumnTrait for Column {
                type EntityName = Entity;
                fn def(&self) -> sea_orm::prelude::ColumnDef {
                    match self {
                        Self::Name => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                    }
                }
                fn enum_type_name(&self) -> Option<&'static str> {
                    match self {
                        Self::Name => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                    }
                }
                fn select_as(
                    &self,
                    expr: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
                    }
                }
                fn save_as(
                    &self,
                    val: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct Entity;
            #[automatically_derived]
            impl ::core::marker::Copy for Entity {}
            #[automatically_derived]
            impl ::core::clone::Clone for Entity {
                #[inline]
                fn clone(&self) -> Entity {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Entity {
                #[inline]
                fn default() -> Entity {
                    Entity {}
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Entity {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Entity")
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::EntityTrait for Entity {
                type Model = Model;
                type ActiveModel = ActiveModel;
                type Column = Column;
                type PrimaryKey = PrimaryKey;
                type Relation = Relation;
            }
            #[automatically_derived]
            impl sea_orm::Iden for Entity {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Entity {
                fn as_str(&self) -> &str {
                    <Self as sea_orm::EntityName>::table_name(self)
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::EntityName for Entity {
                fn schema_name(&self) -> Option<&str> {
                    None
                }
                fn table_name(&self) -> &str {
                    "category"
                }
                fn comment(&self) -> Option<&str> {
                    None
                }
            }
            /// Generated by sea-orm-macros
            pub enum PrimaryKey {
                /// Generated by sea-orm-macros
                Name,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PrimaryKey {}
            #[automatically_derived]
            impl ::core::clone::Clone for PrimaryKey {
                #[inline]
                fn clone(&self) -> PrimaryKey {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrimaryKey {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Name")
                }
            }
            ///An iterator over the variants of [PrimaryKey]
            #[allow(missing_copy_implementations)]
            pub struct PrimaryKeyIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for PrimaryKeyIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
                }
            }
            impl PrimaryKeyIter {
                fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                    match idx {
                        0usize => ::core::option::Option::Some(PrimaryKey::Name),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                type Iterator = PrimaryKeyIter;
                fn iter() -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for PrimaryKeyIter {
                type Item = PrimaryKey;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        PrimaryKeyIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for PrimaryKeyIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for PrimaryKeyIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        PrimaryKeyIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for PrimaryKeyIter {}
            impl Clone for PrimaryKeyIter {
                fn clone(&self) -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for PrimaryKey {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for PrimaryKey {
                fn as_str(&self) -> &str {
                    match self {
                        Self::Name => "name",
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                type Column = Column;
                fn into_column(self) -> Self::Column {
                    match self {
                        Self::Name => Self::Column::Name,
                    }
                }
                fn from_column(col: Self::Column) -> Option<Self> {
                    match col {
                        Self::Column::Name => Some(Self::Name),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl PrimaryKeyTrait for PrimaryKey {
                type ValueType = String;
                fn auto_increment() -> bool {
                    false
                }
            }
            #[automatically_derived]
            impl sea_orm::FromQueryResult for Model {
                fn from_query_result(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::DbErr> {
                    Ok(Self {
                        name: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                                    )
                                    .into(),
                            )?,
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::ModelTrait for Model {
                type Entity = Entity;
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                ) -> sea_orm::Value {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                            self.name.clone().into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
                fn set(
                    &mut self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                            self.name = v.unwrap();
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct ActiveModel {
                /// Generated by sea-orm-macros
                pub name: sea_orm::ActiveValue<String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActiveModel {
                #[inline]
                fn clone(&self) -> ActiveModel {
                    ActiveModel {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActiveModel {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ActiveModel",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActiveModel {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActiveModel {
                #[inline]
                fn eq(&self, other: &ActiveModel) -> bool {
                    self.name == other.name
                }
            }
            #[automatically_derived]
            impl std::default::Default for ActiveModel {
                fn default() -> Self {
                    <Self as sea_orm::ActiveModelBehavior>::new()
                }
            }
            #[automatically_derived]
            impl std::convert::From<Model> for ActiveModel {
                fn from(m: Model) -> Self {
                    Self {
                        name: sea_orm::ActiveValue::Unchanged(m.name),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                fn into_active_model(self) -> ActiveModel {
                    self.into()
                }
            }
            #[automatically_derived]
            impl sea_orm::ActiveModelTrait for ActiveModel {
                type Entity = Entity;
                fn take(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.name);
                            value.into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            self.name.clone().into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn try_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) -> Result<(), sea_orm::DbErr> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            self.name = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        _ => {
                            return Err(
                                sea_orm::DbErr::Type(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "This ActiveModel does not have this field: {0}",
                                                sea_orm::IdenStatic::as_str(&c),
                                            ),
                                        )
                                    }),
                                ),
                            );
                        }
                    }
                    Ok(())
                }
                fn not_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            self.name = sea_orm::ActiveValue::NotSet;
                        }
                        _ => {}
                    }
                }
                fn is_not_set(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> bool {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            self.name.is_not_set()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
                fn default() -> Self {
                    Self {
                        name: sea_orm::ActiveValue::NotSet,
                    }
                }
                fn default_values() -> Self {
                    use sea_orm::value::{
                        DefaultActiveValue, DefaultActiveValueNone,
                        DefaultActiveValueNotSet,
                    };
                    let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                    default.name = (&default.name).default_value();
                    default
                }
                fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                            self.name.reset()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
            }
            #[automatically_derived]
            impl std::convert::TryFrom<ActiveModel> for Model {
                type Error = sea_orm::DbErr;
                fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.name {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
                    }
                    Ok(Self {
                        name: a.name.into_value().unwrap().unwrap(),
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::TryIntoModel<Model> for ActiveModel {
                fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                    self.try_into()
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Model {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Model {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Model",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Model {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private228::Ok(__Field::__field0),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private228::Ok(__Field::__field0),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<Model>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Model;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct Model",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Model with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(Model { name: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("name")?
                                    }
                                };
                                _serde::__private228::Ok(Model { name: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Model",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<Model>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub enum Relation {
                #[sea_orm(has_many = "super::product::Entity")]
                Product,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Relation {}
            #[automatically_derived]
            impl ::core::clone::Clone for Relation {
                #[inline]
                fn clone(&self) -> Relation {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Relation {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Product")
                }
            }
            ///An iterator over the variants of [Relation]
            #[allow(missing_copy_implementations)]
            pub struct RelationIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for RelationIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RelationIter").field("len", &self.len()).finish()
                }
            }
            impl RelationIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                    match idx {
                        0usize => ::core::option::Option::Some(Relation::Product),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Relation {
                type Iterator = RelationIter;
                fn iter() -> RelationIter {
                    RelationIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for RelationIter {
                type Item = Relation;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        RelationIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for RelationIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for RelationIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        RelationIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for RelationIter {}
            impl Clone for RelationIter {
                fn clone(&self) -> RelationIter {
                    RelationIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::RelationTrait for Relation {
                fn def(&self) -> sea_orm::entity::RelationDef {
                    match self {
                        Self::Product => Entity::has_many(super::product::Entity).into(),
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("No RelationDef for Relation"),
                            );
                        }
                    }
                }
            }
            impl Related<super::product::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::Product.def()
                }
            }
            impl ActiveModelBehavior for ActiveModel {}
        }
        pub mod product {
            //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
            use sea_orm::entity::prelude::*;
            use serde::{Deserialize, Serialize};
            #[sea_orm(table_name = "product")]
            pub struct Model {
                #[sea_orm(primary_key)]
                pub id: i32,
                pub title: String,
                pub price: i32,
                pub category: String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Model {
                #[inline]
                fn clone(&self) -> Model {
                    Model {
                        id: ::core::clone::Clone::clone(&self.id),
                        title: ::core::clone::Clone::clone(&self.title),
                        price: ::core::clone::Clone::clone(&self.price),
                        category: ::core::clone::Clone::clone(&self.category),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Model {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Model",
                        "id",
                        &self.id,
                        "title",
                        &self.title,
                        "price",
                        &self.price,
                        "category",
                        &&self.category,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Model {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Model {
                #[inline]
                fn eq(&self, other: &Model) -> bool {
                    self.id == other.id && self.price == other.price
                        && self.title == other.title && self.category == other.category
                }
            }
            /// Generated by sea-orm-macros
            pub enum Column {
                /// Generated by sea-orm-macros
                Id,
                /// Generated by sea-orm-macros
                Title,
                /// Generated by sea-orm-macros
                Price,
                /// Generated by sea-orm-macros
                Category,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Column {}
            #[automatically_derived]
            impl ::core::clone::Clone for Column {
                #[inline]
                fn clone(&self) -> Column {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Column {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Column::Id => "Id",
                            Column::Title => "Title",
                            Column::Price => "Price",
                            Column::Category => "Category",
                        },
                    )
                }
            }
            ///An iterator over the variants of [Column]
            #[allow(missing_copy_implementations)]
            pub struct ColumnIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for ColumnIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                }
            }
            impl ColumnIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                    match idx {
                        0usize => ::core::option::Option::Some(Column::Id),
                        1usize => ::core::option::Option::Some(Column::Title),
                        2usize => ::core::option::Option::Some(Column::Price),
                        3usize => ::core::option::Option::Some(Column::Category),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Column {
                type Iterator = ColumnIter;
                fn iter() -> ColumnIter {
                    ColumnIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ColumnIter {
                type Item = Column;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 4usize {
                        0
                    } else {
                        4usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 4usize {
                        self.idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ColumnIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ColumnIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ColumnIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 4usize {
                        self.back_idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ColumnIter::get(self, 4usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ColumnIter {}
            impl Clone for ColumnIter {
                fn clone(&self) -> ColumnIter {
                    ColumnIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl Column {
                fn default_as_str(&self) -> &str {
                    match self {
                        Self::Id => "id",
                        Self::Title => "title",
                        Self::Price => "price",
                        Self::Category => "category",
                    }
                }
            }
            #[automatically_derived]
            impl std::str::FromStr for Column {
                type Err = sea_orm::ColumnFromStrErr;
                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    match s {
                        "id" | "id" | "id" => Ok(Column::Id),
                        "title" | "title" | "title" => Ok(Column::Title),
                        "price" | "price" | "price" => Ok(Column::Price),
                        "category" | "category" | "category" => Ok(Column::Category),
                        _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for Column {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Column {
                fn as_str(&self) -> &str {
                    self.default_as_str()
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::ColumnTrait for Column {
                type EntityName = Entity;
                fn def(&self) -> sea_orm::prelude::ColumnDef {
                    match self {
                        Self::Id => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::Integer,
                            )
                        }
                        Self::Title => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                        Self::Price => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::Integer,
                            )
                        }
                        Self::Category => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                    }
                }
                fn enum_type_name(&self) -> Option<&'static str> {
                    match self {
                        Self::Id => {
                            <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::Title => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::Price => {
                            <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::Category => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                    }
                }
                fn select_as(
                    &self,
                    expr: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
                    }
                }
                fn save_as(
                    &self,
                    val: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct Entity;
            #[automatically_derived]
            impl ::core::marker::Copy for Entity {}
            #[automatically_derived]
            impl ::core::clone::Clone for Entity {
                #[inline]
                fn clone(&self) -> Entity {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Entity {
                #[inline]
                fn default() -> Entity {
                    Entity {}
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Entity {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Entity")
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::EntityTrait for Entity {
                type Model = Model;
                type ActiveModel = ActiveModel;
                type Column = Column;
                type PrimaryKey = PrimaryKey;
                type Relation = Relation;
            }
            #[automatically_derived]
            impl sea_orm::Iden for Entity {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Entity {
                fn as_str(&self) -> &str {
                    <Self as sea_orm::EntityName>::table_name(self)
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::EntityName for Entity {
                fn schema_name(&self) -> Option<&str> {
                    None
                }
                fn table_name(&self) -> &str {
                    "product"
                }
                fn comment(&self) -> Option<&str> {
                    None
                }
            }
            /// Generated by sea-orm-macros
            pub enum PrimaryKey {
                /// Generated by sea-orm-macros
                Id,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PrimaryKey {}
            #[automatically_derived]
            impl ::core::clone::Clone for PrimaryKey {
                #[inline]
                fn clone(&self) -> PrimaryKey {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrimaryKey {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Id")
                }
            }
            ///An iterator over the variants of [PrimaryKey]
            #[allow(missing_copy_implementations)]
            pub struct PrimaryKeyIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for PrimaryKeyIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
                }
            }
            impl PrimaryKeyIter {
                fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                    match idx {
                        0usize => ::core::option::Option::Some(PrimaryKey::Id),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                type Iterator = PrimaryKeyIter;
                fn iter() -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for PrimaryKeyIter {
                type Item = PrimaryKey;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        PrimaryKeyIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for PrimaryKeyIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for PrimaryKeyIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        PrimaryKeyIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for PrimaryKeyIter {}
            impl Clone for PrimaryKeyIter {
                fn clone(&self) -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for PrimaryKey {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for PrimaryKey {
                fn as_str(&self) -> &str {
                    match self {
                        Self::Id => "id",
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                type Column = Column;
                fn into_column(self) -> Self::Column {
                    match self {
                        Self::Id => Self::Column::Id,
                    }
                }
                fn from_column(col: Self::Column) -> Option<Self> {
                    match col {
                        Self::Column::Id => Some(Self::Id),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl PrimaryKeyTrait for PrimaryKey {
                type ValueType = i32;
                fn auto_increment() -> bool {
                    true
                }
            }
            #[automatically_derived]
            impl sea_orm::FromQueryResult for Model {
                fn from_query_result(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::DbErr> {
                    Ok(Self {
                        id: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                                    )
                                    .into(),
                            )?,
                        title: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Title,
                                    )
                                    .into(),
                            )?,
                        price: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Price,
                                    )
                                    .into(),
                            )?,
                        category: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Category,
                                    )
                                    .into(),
                            )?,
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::ModelTrait for Model {
                type Entity = Entity;
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                ) -> sea_orm::Value {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                            self.id.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Title => {
                            self.title.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Price => {
                            self.price.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Category => {
                            self.category.clone().into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
                fn set(
                    &mut self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                            self.id = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Title => {
                            self.title = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Price => {
                            self.price = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Category => {
                            self.category = v.unwrap();
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct ActiveModel {
                /// Generated by sea-orm-macros
                pub id: sea_orm::ActiveValue<i32>,
                /// Generated by sea-orm-macros
                pub title: sea_orm::ActiveValue<String>,
                /// Generated by sea-orm-macros
                pub price: sea_orm::ActiveValue<i32>,
                /// Generated by sea-orm-macros
                pub category: sea_orm::ActiveValue<String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActiveModel {
                #[inline]
                fn clone(&self) -> ActiveModel {
                    ActiveModel {
                        id: ::core::clone::Clone::clone(&self.id),
                        title: ::core::clone::Clone::clone(&self.title),
                        price: ::core::clone::Clone::clone(&self.price),
                        category: ::core::clone::Clone::clone(&self.category),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActiveModel {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "ActiveModel",
                        "id",
                        &self.id,
                        "title",
                        &self.title,
                        "price",
                        &self.price,
                        "category",
                        &&self.category,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActiveModel {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActiveModel {
                #[inline]
                fn eq(&self, other: &ActiveModel) -> bool {
                    self.id == other.id && self.title == other.title
                        && self.price == other.price && self.category == other.category
                }
            }
            #[automatically_derived]
            impl std::default::Default for ActiveModel {
                fn default() -> Self {
                    <Self as sea_orm::ActiveModelBehavior>::new()
                }
            }
            #[automatically_derived]
            impl std::convert::From<Model> for ActiveModel {
                fn from(m: Model) -> Self {
                    Self {
                        id: sea_orm::ActiveValue::Unchanged(m.id),
                        title: sea_orm::ActiveValue::Unchanged(m.title),
                        price: sea_orm::ActiveValue::Unchanged(m.price),
                        category: sea_orm::ActiveValue::Unchanged(m.category),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                fn into_active_model(self) -> ActiveModel {
                    self.into()
                }
            }
            #[automatically_derived]
            impl sea_orm::ActiveModelTrait for ActiveModel {
                type Entity = Entity;
                fn take(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.id);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.title);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.price);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.category);
                            value.into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            self.title.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            self.price.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            self.category.clone().into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn try_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) -> Result<(), sea_orm::DbErr> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            self.title = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            self.price = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            self.category = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        _ => {
                            return Err(
                                sea_orm::DbErr::Type(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "This ActiveModel does not have this field: {0}",
                                                sea_orm::IdenStatic::as_str(&c),
                                            ),
                                        )
                                    }),
                                ),
                            );
                        }
                    }
                    Ok(())
                }
                fn not_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            self.title = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            self.price = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            self.category = sea_orm::ActiveValue::NotSet;
                        }
                        _ => {}
                    }
                }
                fn is_not_set(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> bool {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            self.title.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            self.price.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            self.category.is_not_set()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
                fn default() -> Self {
                    Self {
                        id: sea_orm::ActiveValue::NotSet,
                        title: sea_orm::ActiveValue::NotSet,
                        price: sea_orm::ActiveValue::NotSet,
                        category: sea_orm::ActiveValue::NotSet,
                    }
                }
                fn default_values() -> Self {
                    use sea_orm::value::{
                        DefaultActiveValue, DefaultActiveValueNone,
                        DefaultActiveValueNotSet,
                    };
                    let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                    default.id = (&default.id).default_value();
                    default.title = (&default.title).default_value();
                    default.price = (&default.price).default_value();
                    default.category = (&default.category).default_value();
                    default
                }
                fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Title => {
                            self.title.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Price => {
                            self.price.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Category => {
                            self.category.reset()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
            }
            #[automatically_derived]
            impl std::convert::TryFrom<ActiveModel> for Model {
                type Error = sea_orm::DbErr;
                fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.id {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.title {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("title".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.price {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("price".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.category {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("category".to_owned()));
                    }
                    Ok(Self {
                        id: a.id.into_value().unwrap().unwrap(),
                        title: a.title.into_value().unwrap().unwrap(),
                        price: a.price.into_value().unwrap().unwrap(),
                        category: a.category.into_value().unwrap().unwrap(),
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::TryIntoModel<Model> for ActiveModel {
                fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                    self.try_into()
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Model {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Model {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Model",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "title",
                            &self.title,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "price",
                            &self.price,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "category",
                            &self.category,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Model {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    3u64 => _serde::__private228::Ok(__Field::__field3),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private228::Ok(__Field::__field0),
                                    "title" => _serde::__private228::Ok(__Field::__field1),
                                    "price" => _serde::__private228::Ok(__Field::__field2),
                                    "category" => _serde::__private228::Ok(__Field::__field3),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private228::Ok(__Field::__field0),
                                    b"title" => _serde::__private228::Ok(__Field::__field1),
                                    b"price" => _serde::__private228::Ok(__Field::__field2),
                                    b"category" => _serde::__private228::Ok(__Field::__field3),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<Model>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Model;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct Model",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Model with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Model with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Model with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Model with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    id: __field0,
                                    title: __field1,
                                    price: __field2,
                                    category: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field3: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("price"),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private228::Option::is_some(&__field3) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "category",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("title")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("price")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private228::Some(__field3) => __field3,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("category")?
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    id: __field0,
                                    title: __field1,
                                    price: __field2,
                                    category: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "title",
                            "price",
                            "category",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Model",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<Model>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub enum Relation {
                #[sea_orm(
                    belongs_to = "super::category::Entity",
                    from = "Column::Category",
                    to = "super::category::Column::Name",
                    on_update = "NoAction",
                    on_delete = "NoAction"
                )]
                Category,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Relation {}
            #[automatically_derived]
            impl ::core::clone::Clone for Relation {
                #[inline]
                fn clone(&self) -> Relation {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Relation {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Category")
                }
            }
            ///An iterator over the variants of [Relation]
            #[allow(missing_copy_implementations)]
            pub struct RelationIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for RelationIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RelationIter").field("len", &self.len()).finish()
                }
            }
            impl RelationIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                    match idx {
                        0usize => ::core::option::Option::Some(Relation::Category),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Relation {
                type Iterator = RelationIter;
                fn iter() -> RelationIter {
                    RelationIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for RelationIter {
                type Item = Relation;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        RelationIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for RelationIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for RelationIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        RelationIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for RelationIter {}
            impl Clone for RelationIter {
                fn clone(&self) -> RelationIter {
                    RelationIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::RelationTrait for Relation {
                fn def(&self) -> sea_orm::entity::RelationDef {
                    match self {
                        Self::Category => {
                            Entity::belongs_to(super::category::Entity)
                                .from(Column::Category)
                                .to(super::category::Column::Name)
                                .on_update(sea_orm::prelude::ForeignKeyAction::NoAction)
                                .on_delete(sea_orm::prelude::ForeignKeyAction::NoAction)
                                .into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("No RelationDef for Relation"),
                            );
                        }
                    }
                }
            }
            impl Related<super::category::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::Category.def()
                }
            }
            impl ActiveModelBehavior for ActiveModel {}
        }
        pub mod refresh_token {
            //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
            use sea_orm::entity::prelude::*;
            use serde::{Deserialize, Serialize};
            #[sea_orm(table_name = "refresh_token")]
            pub struct Model {
                #[sea_orm(primary_key, auto_increment = false)]
                pub token: String,
                pub user_id: i32,
                pub expires_at: DateTime,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Model {
                #[inline]
                fn clone(&self) -> Model {
                    Model {
                        token: ::core::clone::Clone::clone(&self.token),
                        user_id: ::core::clone::Clone::clone(&self.user_id),
                        expires_at: ::core::clone::Clone::clone(&self.expires_at),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Model {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Model",
                        "token",
                        &self.token,
                        "user_id",
                        &self.user_id,
                        "expires_at",
                        &&self.expires_at,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Model {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Model {
                #[inline]
                fn eq(&self, other: &Model) -> bool {
                    self.user_id == other.user_id && self.token == other.token
                        && self.expires_at == other.expires_at
                }
            }
            /// Generated by sea-orm-macros
            pub enum Column {
                /// Generated by sea-orm-macros
                Token,
                /// Generated by sea-orm-macros
                UserId,
                /// Generated by sea-orm-macros
                ExpiresAt,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Column {}
            #[automatically_derived]
            impl ::core::clone::Clone for Column {
                #[inline]
                fn clone(&self) -> Column {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Column {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Column::Token => "Token",
                            Column::UserId => "UserId",
                            Column::ExpiresAt => "ExpiresAt",
                        },
                    )
                }
            }
            ///An iterator over the variants of [Column]
            #[allow(missing_copy_implementations)]
            pub struct ColumnIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for ColumnIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                }
            }
            impl ColumnIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                    match idx {
                        0usize => ::core::option::Option::Some(Column::Token),
                        1usize => ::core::option::Option::Some(Column::UserId),
                        2usize => ::core::option::Option::Some(Column::ExpiresAt),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Column {
                type Iterator = ColumnIter;
                fn iter() -> ColumnIter {
                    ColumnIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ColumnIter {
                type Item = Column;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 3usize {
                        0
                    } else {
                        3usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 3usize {
                        self.idx = 3usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ColumnIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ColumnIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ColumnIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 3usize {
                        self.back_idx = 3usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ColumnIter::get(self, 3usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ColumnIter {}
            impl Clone for ColumnIter {
                fn clone(&self) -> ColumnIter {
                    ColumnIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl Column {
                fn default_as_str(&self) -> &str {
                    match self {
                        Self::Token => "token",
                        Self::UserId => "user_id",
                        Self::ExpiresAt => "expires_at",
                    }
                }
            }
            #[automatically_derived]
            impl std::str::FromStr for Column {
                type Err = sea_orm::ColumnFromStrErr;
                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    match s {
                        "token" | "token" | "token" => Ok(Column::Token),
                        "user_id" | "userId" | "user_id" => Ok(Column::UserId),
                        "expires_at" | "expiresAt" | "expires_at" => {
                            Ok(Column::ExpiresAt)
                        }
                        _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for Column {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Column {
                fn as_str(&self) -> &str {
                    self.default_as_str()
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::ColumnTrait for Column {
                type EntityName = Entity;
                fn def(&self) -> sea_orm::prelude::ColumnDef {
                    match self {
                        Self::Token => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                        Self::UserId => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::Integer,
                            )
                        }
                        Self::ExpiresAt => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::DateTime,
                            )
                        }
                    }
                }
                fn enum_type_name(&self) -> Option<&'static str> {
                    match self {
                        Self::Token => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::UserId => {
                            <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::ExpiresAt => {
                            <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                    }
                }
                fn select_as(
                    &self,
                    expr: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
                    }
                }
                fn save_as(
                    &self,
                    val: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct Entity;
            #[automatically_derived]
            impl ::core::marker::Copy for Entity {}
            #[automatically_derived]
            impl ::core::clone::Clone for Entity {
                #[inline]
                fn clone(&self) -> Entity {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Entity {
                #[inline]
                fn default() -> Entity {
                    Entity {}
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Entity {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Entity")
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::EntityTrait for Entity {
                type Model = Model;
                type ActiveModel = ActiveModel;
                type Column = Column;
                type PrimaryKey = PrimaryKey;
                type Relation = Relation;
            }
            #[automatically_derived]
            impl sea_orm::Iden for Entity {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Entity {
                fn as_str(&self) -> &str {
                    <Self as sea_orm::EntityName>::table_name(self)
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::EntityName for Entity {
                fn schema_name(&self) -> Option<&str> {
                    None
                }
                fn table_name(&self) -> &str {
                    "refresh_token"
                }
                fn comment(&self) -> Option<&str> {
                    None
                }
            }
            /// Generated by sea-orm-macros
            pub enum PrimaryKey {
                /// Generated by sea-orm-macros
                Token,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PrimaryKey {}
            #[automatically_derived]
            impl ::core::clone::Clone for PrimaryKey {
                #[inline]
                fn clone(&self) -> PrimaryKey {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrimaryKey {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Token")
                }
            }
            ///An iterator over the variants of [PrimaryKey]
            #[allow(missing_copy_implementations)]
            pub struct PrimaryKeyIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for PrimaryKeyIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
                }
            }
            impl PrimaryKeyIter {
                fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                    match idx {
                        0usize => ::core::option::Option::Some(PrimaryKey::Token),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                type Iterator = PrimaryKeyIter;
                fn iter() -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for PrimaryKeyIter {
                type Item = PrimaryKey;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        PrimaryKeyIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for PrimaryKeyIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for PrimaryKeyIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        PrimaryKeyIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for PrimaryKeyIter {}
            impl Clone for PrimaryKeyIter {
                fn clone(&self) -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for PrimaryKey {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for PrimaryKey {
                fn as_str(&self) -> &str {
                    match self {
                        Self::Token => "token",
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                type Column = Column;
                fn into_column(self) -> Self::Column {
                    match self {
                        Self::Token => Self::Column::Token,
                    }
                }
                fn from_column(col: Self::Column) -> Option<Self> {
                    match col {
                        Self::Column::Token => Some(Self::Token),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl PrimaryKeyTrait for PrimaryKey {
                type ValueType = String;
                fn auto_increment() -> bool {
                    false
                }
            }
            #[automatically_derived]
            impl sea_orm::FromQueryResult for Model {
                fn from_query_result(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::DbErr> {
                    Ok(Self {
                        token: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Token,
                                    )
                                    .into(),
                            )?,
                        user_id: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserId,
                                    )
                                    .into(),
                            )?,
                        expires_at: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::ExpiresAt,
                                    )
                                    .into(),
                            )?,
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::ModelTrait for Model {
                type Entity = Entity;
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                ) -> sea_orm::Value {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Token => {
                            self.token.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserId => {
                            self.user_id.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at.clone().into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
                fn set(
                    &mut self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Token => {
                            self.token = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserId => {
                            self.user_id = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at = v.unwrap();
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct ActiveModel {
                /// Generated by sea-orm-macros
                pub token: sea_orm::ActiveValue<String>,
                /// Generated by sea-orm-macros
                pub user_id: sea_orm::ActiveValue<i32>,
                /// Generated by sea-orm-macros
                pub expires_at: sea_orm::ActiveValue<DateTime>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActiveModel {
                #[inline]
                fn clone(&self) -> ActiveModel {
                    ActiveModel {
                        token: ::core::clone::Clone::clone(&self.token),
                        user_id: ::core::clone::Clone::clone(&self.user_id),
                        expires_at: ::core::clone::Clone::clone(&self.expires_at),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActiveModel {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ActiveModel",
                        "token",
                        &self.token,
                        "user_id",
                        &self.user_id,
                        "expires_at",
                        &&self.expires_at,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActiveModel {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActiveModel {
                #[inline]
                fn eq(&self, other: &ActiveModel) -> bool {
                    self.token == other.token && self.user_id == other.user_id
                        && self.expires_at == other.expires_at
                }
            }
            #[automatically_derived]
            impl std::default::Default for ActiveModel {
                fn default() -> Self {
                    <Self as sea_orm::ActiveModelBehavior>::new()
                }
            }
            #[automatically_derived]
            impl std::convert::From<Model> for ActiveModel {
                fn from(m: Model) -> Self {
                    Self {
                        token: sea_orm::ActiveValue::Unchanged(m.token),
                        user_id: sea_orm::ActiveValue::Unchanged(m.user_id),
                        expires_at: sea_orm::ActiveValue::Unchanged(m.expires_at),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                fn into_active_model(self) -> ActiveModel {
                    self.into()
                }
            }
            #[automatically_derived]
            impl sea_orm::ActiveModelTrait for ActiveModel {
                type Entity = Entity;
                fn take(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.token);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.user_id);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.expires_at);
                            value.into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            self.token.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            self.user_id.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at.clone().into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn try_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) -> Result<(), sea_orm::DbErr> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            self.token = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            self.user_id = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        _ => {
                            return Err(
                                sea_orm::DbErr::Type(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "This ActiveModel does not have this field: {0}",
                                                sea_orm::IdenStatic::as_str(&c),
                                            ),
                                        )
                                    }),
                                ),
                            );
                        }
                    }
                    Ok(())
                }
                fn not_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            self.token = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            self.user_id = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at = sea_orm::ActiveValue::NotSet;
                        }
                        _ => {}
                    }
                }
                fn is_not_set(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> bool {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            self.token.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            self.user_id.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at.is_not_set()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
                fn default() -> Self {
                    Self {
                        token: sea_orm::ActiveValue::NotSet,
                        user_id: sea_orm::ActiveValue::NotSet,
                        expires_at: sea_orm::ActiveValue::NotSet,
                    }
                }
                fn default_values() -> Self {
                    use sea_orm::value::{
                        DefaultActiveValue, DefaultActiveValueNone,
                        DefaultActiveValueNotSet,
                    };
                    let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                    default.token = (&default.token).default_value();
                    default.user_id = (&default.user_id).default_value();
                    default.expires_at = (&default.expires_at).default_value();
                    default
                }
                fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                            self.token.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                            self.user_id.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::ExpiresAt => {
                            self.expires_at.reset()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
            }
            #[automatically_derived]
            impl std::convert::TryFrom<ActiveModel> for Model {
                type Error = sea_orm::DbErr;
                fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.token {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("token".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.user_id {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("user_id".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.expires_at {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("expires_at".to_owned()));
                    }
                    Ok(Self {
                        token: a.token.into_value().unwrap().unwrap(),
                        user_id: a.user_id.into_value().unwrap().unwrap(),
                        expires_at: a.expires_at.into_value().unwrap().unwrap(),
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::TryIntoModel<Model> for ActiveModel {
                fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                    self.try_into()
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Model {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                    let _: ::core::cmp::AssertParamIsEq<DateTime>;
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Model {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Model",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token",
                            &self.token,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "user_id",
                            &self.user_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expires_at",
                            &self.expires_at,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Model {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "token" => _serde::__private228::Ok(__Field::__field0),
                                    "user_id" => _serde::__private228::Ok(__Field::__field1),
                                    "expires_at" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"token" => _serde::__private228::Ok(__Field::__field0),
                                    b"user_id" => _serde::__private228::Ok(__Field::__field1),
                                    b"expires_at" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<Model>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Model;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct Model",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    DateTime,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    token: __field0,
                                    user_id: __field1,
                                    expires_at: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<DateTime> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "user_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "expires_at",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("token")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("user_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("expires_at")?
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    token: __field0,
                                    user_id: __field1,
                                    expires_at: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "token",
                            "user_id",
                            "expires_at",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Model",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<Model>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub enum Relation {
                #[sea_orm(
                    belongs_to = "super::users::Entity",
                    from = "Column::UserId",
                    to = "super::users::Column::Id",
                    on_update = "NoAction",
                    on_delete = "Cascade"
                )]
                Users,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Relation {}
            #[automatically_derived]
            impl ::core::clone::Clone for Relation {
                #[inline]
                fn clone(&self) -> Relation {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Relation {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Users")
                }
            }
            ///An iterator over the variants of [Relation]
            #[allow(missing_copy_implementations)]
            pub struct RelationIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for RelationIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RelationIter").field("len", &self.len()).finish()
                }
            }
            impl RelationIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                    match idx {
                        0usize => ::core::option::Option::Some(Relation::Users),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Relation {
                type Iterator = RelationIter;
                fn iter() -> RelationIter {
                    RelationIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for RelationIter {
                type Item = Relation;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        RelationIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for RelationIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for RelationIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        RelationIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for RelationIter {}
            impl Clone for RelationIter {
                fn clone(&self) -> RelationIter {
                    RelationIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::RelationTrait for Relation {
                fn def(&self) -> sea_orm::entity::RelationDef {
                    match self {
                        Self::Users => {
                            Entity::belongs_to(super::users::Entity)
                                .from(Column::UserId)
                                .to(super::users::Column::Id)
                                .on_update(sea_orm::prelude::ForeignKeyAction::NoAction)
                                .on_delete(sea_orm::prelude::ForeignKeyAction::Cascade)
                                .into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("No RelationDef for Relation"),
                            );
                        }
                    }
                }
            }
            impl Related<super::users::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::Users.def()
                }
            }
            impl ActiveModelBehavior for ActiveModel {}
        }
        pub mod users {
            //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19
            use sea_orm::entity::prelude::*;
            use serde::{Deserialize, Serialize};
            #[sea_orm(table_name = "users")]
            pub struct Model {
                #[sea_orm(primary_key)]
                pub id: i32,
                pub username: String,
                pub password: String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Model {
                #[inline]
                fn clone(&self) -> Model {
                    Model {
                        id: ::core::clone::Clone::clone(&self.id),
                        username: ::core::clone::Clone::clone(&self.username),
                        password: ::core::clone::Clone::clone(&self.password),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Model {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Model",
                        "id",
                        &self.id,
                        "username",
                        &self.username,
                        "password",
                        &&self.password,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Model {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Model {
                #[inline]
                fn eq(&self, other: &Model) -> bool {
                    self.id == other.id && self.username == other.username
                        && self.password == other.password
                }
            }
            /// Generated by sea-orm-macros
            pub enum Column {
                /// Generated by sea-orm-macros
                Id,
                /// Generated by sea-orm-macros
                Username,
                /// Generated by sea-orm-macros
                Password,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Column {}
            #[automatically_derived]
            impl ::core::clone::Clone for Column {
                #[inline]
                fn clone(&self) -> Column {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Column {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Column::Id => "Id",
                            Column::Username => "Username",
                            Column::Password => "Password",
                        },
                    )
                }
            }
            ///An iterator over the variants of [Column]
            #[allow(missing_copy_implementations)]
            pub struct ColumnIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for ColumnIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                }
            }
            impl ColumnIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                    match idx {
                        0usize => ::core::option::Option::Some(Column::Id),
                        1usize => ::core::option::Option::Some(Column::Username),
                        2usize => ::core::option::Option::Some(Column::Password),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Column {
                type Iterator = ColumnIter;
                fn iter() -> ColumnIter {
                    ColumnIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ColumnIter {
                type Item = Column;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 3usize {
                        0
                    } else {
                        3usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 3usize {
                        self.idx = 3usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ColumnIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ColumnIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ColumnIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 3usize {
                        self.back_idx = 3usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ColumnIter::get(self, 3usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ColumnIter {}
            impl Clone for ColumnIter {
                fn clone(&self) -> ColumnIter {
                    ColumnIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl Column {
                fn default_as_str(&self) -> &str {
                    match self {
                        Self::Id => "id",
                        Self::Username => "username",
                        Self::Password => "password",
                    }
                }
            }
            #[automatically_derived]
            impl std::str::FromStr for Column {
                type Err = sea_orm::ColumnFromStrErr;
                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    match s {
                        "id" | "id" | "id" => Ok(Column::Id),
                        "username" | "username" | "username" => Ok(Column::Username),
                        "password" | "password" | "password" => Ok(Column::Password),
                        _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for Column {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Column {
                fn as_str(&self) -> &str {
                    self.default_as_str()
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::ColumnTrait for Column {
                type EntityName = Entity;
                fn def(&self) -> sea_orm::prelude::ColumnDef {
                    match self {
                        Self::Id => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::Integer,
                            )
                        }
                        Self::Username => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                        Self::Password => {
                            sea_orm::prelude::ColumnTypeTrait::def(
                                sea_orm::prelude::ColumnType::string(None),
                            )
                        }
                    }
                }
                fn enum_type_name(&self) -> Option<&'static str> {
                    match self {
                        Self::Id => {
                            <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::Username => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                        Self::Password => {
                            <String as sea_orm::sea_query::ValueType>::enum_type_name()
                        }
                    }
                }
                fn select_as(
                    &self,
                    expr: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
                    }
                }
                fn save_as(
                    &self,
                    val: sea_orm::sea_query::Expr,
                ) -> sea_orm::sea_query::SimpleExpr {
                    match self {
                        _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct Entity;
            #[automatically_derived]
            impl ::core::marker::Copy for Entity {}
            #[automatically_derived]
            impl ::core::clone::Clone for Entity {
                #[inline]
                fn clone(&self) -> Entity {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Entity {
                #[inline]
                fn default() -> Entity {
                    Entity {}
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Entity {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Entity")
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::EntityTrait for Entity {
                type Model = Model;
                type ActiveModel = ActiveModel;
                type Column = Column;
                type PrimaryKey = PrimaryKey;
                type Relation = Relation;
            }
            #[automatically_derived]
            impl sea_orm::Iden for Entity {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for Entity {
                fn as_str(&self) -> &str {
                    <Self as sea_orm::EntityName>::table_name(self)
                }
            }
            #[automatically_derived]
            impl sea_orm::prelude::EntityName for Entity {
                fn schema_name(&self) -> Option<&str> {
                    None
                }
                fn table_name(&self) -> &str {
                    "users"
                }
                fn comment(&self) -> Option<&str> {
                    None
                }
            }
            /// Generated by sea-orm-macros
            pub enum PrimaryKey {
                /// Generated by sea-orm-macros
                Id,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PrimaryKey {}
            #[automatically_derived]
            impl ::core::clone::Clone for PrimaryKey {
                #[inline]
                fn clone(&self) -> PrimaryKey {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrimaryKey {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Id")
                }
            }
            ///An iterator over the variants of [PrimaryKey]
            #[allow(missing_copy_implementations)]
            pub struct PrimaryKeyIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for PrimaryKeyIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
                }
            }
            impl PrimaryKeyIter {
                fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                    match idx {
                        0usize => ::core::option::Option::Some(PrimaryKey::Id),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                type Iterator = PrimaryKeyIter;
                fn iter() -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for PrimaryKeyIter {
                type Item = PrimaryKey;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        PrimaryKeyIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for PrimaryKeyIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for PrimaryKeyIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        PrimaryKeyIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for PrimaryKeyIter {}
            impl Clone for PrimaryKeyIter {
                fn clone(&self) -> PrimaryKeyIter {
                    PrimaryKeyIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::Iden for PrimaryKey {
                fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                    s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self)))
                        .unwrap();
                }
            }
            #[automatically_derived]
            impl sea_orm::IdenStatic for PrimaryKey {
                fn as_str(&self) -> &str {
                    match self {
                        Self::Id => "id",
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                type Column = Column;
                fn into_column(self) -> Self::Column {
                    match self {
                        Self::Id => Self::Column::Id,
                    }
                }
                fn from_column(col: Self::Column) -> Option<Self> {
                    match col {
                        Self::Column::Id => Some(Self::Id),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl PrimaryKeyTrait for PrimaryKey {
                type ValueType = i32;
                fn auto_increment() -> bool {
                    true
                }
            }
            #[automatically_derived]
            impl sea_orm::FromQueryResult for Model {
                fn from_query_result(
                    row: &sea_orm::QueryResult,
                    pre: &str,
                ) -> std::result::Result<Self, sea_orm::DbErr> {
                    Ok(Self {
                        id: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                                    )
                                    .into(),
                            )?,
                        username: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Username,
                                    )
                                    .into(),
                            )?,
                        password: row
                            .try_get(
                                pre,
                                sea_orm::IdenStatic::as_str(
                                        &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Password,
                                    )
                                    .into(),
                            )?,
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::ModelTrait for Model {
                type Entity = Entity;
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                ) -> sea_orm::Value {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                            self.id.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Username => {
                            self.username.clone().into()
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                            self.password.clone().into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
                fn set(
                    &mut self,
                    c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) {
                    match c {
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                            self.id = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Username => {
                            self.username = v.unwrap();
                        }
                        <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                            self.password = v.unwrap();
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("field does not exist on Model"),
                            );
                        }
                    }
                }
            }
            /// Generated by sea-orm-macros
            pub struct ActiveModel {
                /// Generated by sea-orm-macros
                pub id: sea_orm::ActiveValue<i32>,
                /// Generated by sea-orm-macros
                pub username: sea_orm::ActiveValue<String>,
                /// Generated by sea-orm-macros
                pub password: sea_orm::ActiveValue<String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ActiveModel {
                #[inline]
                fn clone(&self) -> ActiveModel {
                    ActiveModel {
                        id: ::core::clone::Clone::clone(&self.id),
                        username: ::core::clone::Clone::clone(&self.username),
                        password: ::core::clone::Clone::clone(&self.password),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ActiveModel {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ActiveModel",
                        "id",
                        &self.id,
                        "username",
                        &self.username,
                        "password",
                        &&self.password,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ActiveModel {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ActiveModel {
                #[inline]
                fn eq(&self, other: &ActiveModel) -> bool {
                    self.id == other.id && self.username == other.username
                        && self.password == other.password
                }
            }
            #[automatically_derived]
            impl std::default::Default for ActiveModel {
                fn default() -> Self {
                    <Self as sea_orm::ActiveModelBehavior>::new()
                }
            }
            #[automatically_derived]
            impl std::convert::From<Model> for ActiveModel {
                fn from(m: Model) -> Self {
                    Self {
                        id: sea_orm::ActiveValue::Unchanged(m.id),
                        username: sea_orm::ActiveValue::Unchanged(m.username),
                        password: sea_orm::ActiveValue::Unchanged(m.password),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                fn into_active_model(self) -> ActiveModel {
                    self.into()
                }
            }
            #[automatically_derived]
            impl sea_orm::ActiveModelTrait for ActiveModel {
                type Entity = Entity;
                fn take(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.id);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.username);
                            value.into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            let mut value = sea_orm::ActiveValue::NotSet;
                            std::mem::swap(&mut value, &mut self.password);
                            value.into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn get(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> sea_orm::ActiveValue<sea_orm::Value> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            self.username.clone().into_wrapped_value()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            self.password.clone().into_wrapped_value()
                        }
                        _ => sea_orm::ActiveValue::NotSet,
                    }
                }
                fn try_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    v: sea_orm::Value,
                ) -> Result<(), sea_orm::DbErr> {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            self.username = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            self.password = sea_orm::ActiveValue::set(
                                sea_orm::sea_query::ValueType::try_from(v)
                                    .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                            );
                        }
                        _ => {
                            return Err(
                                sea_orm::DbErr::Type(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "This ActiveModel does not have this field: {0}",
                                                sea_orm::IdenStatic::as_str(&c),
                                            ),
                                        )
                                    }),
                                ),
                            );
                        }
                    }
                    Ok(())
                }
                fn not_set(
                    &mut self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            self.username = sea_orm::ActiveValue::NotSet;
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            self.password = sea_orm::ActiveValue::NotSet;
                        }
                        _ => {}
                    }
                }
                fn is_not_set(
                    &self,
                    c: <Self::Entity as sea_orm::EntityTrait>::Column,
                ) -> bool {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            self.username.is_not_set()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            self.password.is_not_set()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
                fn default() -> Self {
                    Self {
                        id: sea_orm::ActiveValue::NotSet,
                        username: sea_orm::ActiveValue::NotSet,
                        password: sea_orm::ActiveValue::NotSet,
                    }
                }
                fn default_values() -> Self {
                    use sea_orm::value::{
                        DefaultActiveValue, DefaultActiveValueNone,
                        DefaultActiveValueNotSet,
                    };
                    let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                    default.id = (&default.id).default_value();
                    default.username = (&default.username).default_value();
                    default.password = (&default.password).default_value();
                    default
                }
                fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
                    match c {
                        <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                            self.id.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                            self.username.reset()
                        }
                        <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                            self.password.reset()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("This ActiveModel does not have this field"),
                            );
                        }
                    }
                }
            }
            #[automatically_derived]
            impl std::convert::TryFrom<ActiveModel> for Model {
                type Error = sea_orm::DbErr;
                fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.id {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.username {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("username".to_owned()));
                    }
                    if #[allow(non_exhaustive_omitted_patterns)]
                    match a.password {
                        sea_orm::ActiveValue::NotSet => true,
                        _ => false,
                    } {
                        return Err(sea_orm::DbErr::AttrNotSet("password".to_owned()));
                    }
                    Ok(Self {
                        id: a.id.into_value().unwrap().unwrap(),
                        username: a.username.into_value().unwrap().unwrap(),
                        password: a.password.into_value().unwrap().unwrap(),
                    })
                }
            }
            #[automatically_derived]
            impl sea_orm::TryIntoModel<Model> for ActiveModel {
                fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                    self.try_into()
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Model {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Model {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Model",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "username",
                            &self.username,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "password",
                            &self.password,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Model {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private228::Ok(__Field::__field0),
                                    1u64 => _serde::__private228::Ok(__Field::__field1),
                                    2u64 => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private228::Ok(__Field::__field0),
                                    "username" => _serde::__private228::Ok(__Field::__field1),
                                    "password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private228::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private228::Ok(__Field::__field0),
                                    b"username" => _serde::__private228::Ok(__Field::__field1),
                                    b"password" => _serde::__private228::Ok(__Field::__field2),
                                    _ => _serde::__private228::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private228::PhantomData<Model>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Model;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private228::Formatter,
                            ) -> _serde::__private228::fmt::Result {
                                _serde::__private228::Formatter::write_str(
                                    __formatter,
                                    "struct Model",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i32,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private228::Some(__value) => __value,
                                    _serde::__private228::None => {
                                        return _serde::__private228::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Model with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private228::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                                let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                                let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                                while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private228::Option::is_some(&__field0) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private228::Option::is_some(&__field1) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "username",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private228::Option::is_some(&__field2) {
                                                return _serde::__private228::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private228::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private228::Some(__field0) => __field0,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private228::Some(__field1) => __field1,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("username")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private228::Some(__field2) => __field2,
                                    _serde::__private228::None => {
                                        _serde::__private228::de::missing_field("password")?
                                    }
                                };
                                _serde::__private228::Ok(Model {
                                    id: __field0,
                                    username: __field1,
                                    password: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "username",
                            "password",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Model",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private228::PhantomData::<Model>,
                                lifetime: _serde::__private228::PhantomData,
                            },
                        )
                    }
                }
            };
            pub enum Relation {
                #[sea_orm(has_many = "super::refresh_token::Entity")]
                RefreshToken,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Relation {}
            #[automatically_derived]
            impl ::core::clone::Clone for Relation {
                #[inline]
                fn clone(&self) -> Relation {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Relation {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "RefreshToken")
                }
            }
            ///An iterator over the variants of [Relation]
            #[allow(missing_copy_implementations)]
            pub struct RelationIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<()>,
            }
            impl ::core::fmt::Debug for RelationIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RelationIter").field("len", &self.len()).finish()
                }
            }
            impl RelationIter {
                fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                    match idx {
                        0usize => ::core::option::Option::Some(Relation::RefreshToken),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl sea_orm::strum::IntoEnumIterator for Relation {
                type Iterator = RelationIter;
                fn iter() -> RelationIter {
                    RelationIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for RelationIter {
                type Item = Relation;
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 1usize {
                        0
                    } else {
                        1usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 1usize {
                        self.idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        RelationIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for RelationIter {
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for RelationIter {
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 1usize {
                        self.back_idx = 1usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        RelationIter::get(self, 1usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for RelationIter {}
            impl Clone for RelationIter {
                fn clone(&self) -> RelationIter {
                    RelationIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[automatically_derived]
            impl sea_orm::entity::RelationTrait for Relation {
                fn def(&self) -> sea_orm::entity::RelationDef {
                    match self {
                        Self::RefreshToken => {
                            Entity::has_many(super::refresh_token::Entity).into()
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("No RelationDef for Relation"),
                            );
                        }
                    }
                }
            }
            impl Related<super::refresh_token::Entity> for Entity {
                fn to() -> RelationDef {
                    Relation::RefreshToken.def()
                }
            }
            impl ActiveModelBehavior for ActiveModel {}
        }
    }
    pub mod style {
        use manganis::Asset;
        pub const TACIT: Asset = {
            const __ASSET_SOURCE_PATH: &'static str = "/home/dolto/study/axum/axum_project/fullstack/res/tacit-css-1.9.5.min.css";
            const __ASSET_OPTIONS: manganis::AssetOptions = manganis::AssetOptions::builder()
                .into_asset_options();
            const __ASSET_HASH: &'static str = "b9857079a6db183a";
            const __ASSET: manganis::BundledAsset = manganis::macro_helpers::create_bundled_asset(
                __ASSET_SOURCE_PATH,
                __ASSET_OPTIONS,
            );
            const __BUFFER: manganis::macro_helpers::const_serialize::ConstVec<u8> = manganis::macro_helpers::serialize_asset(
                &__ASSET,
            );
            const __BYTES: &[u8] = __BUFFER.as_ref();
            const __LEN: usize = __BYTES.len();
            #[unsafe(export_name = "__MANGANIS__b9857079a6db183a")]
            static __LINK_SECTION: [u8; __LEN] = manganis::macro_helpers::copy_bytes(
                __BYTES,
            );
            static __REFERENCE_TO_LINK_SECTION: &'static [u8] = &__LINK_SECTION;
            manganis::Asset::new(|| unsafe {
                std::ptr::read_volatile(&__REFERENCE_TO_LINK_SECTION)
            })
        };
    }
}
pub mod router {
    pub mod api {
        use axum::Router;
        use crate::resources::dto::fullstack_extension::AppExtension;
        pub mod auth {
            use crate::resources::dto::fullstack_extension::AppExtension;
            use crate::resources::dto::user::{ReqUser, Tokens};
            use axum::extract::State;
            use axum::{Json, Router, debug_handler};
            use reqwest::StatusCode;
            use sea_orm::{
                ColumnTrait, DatabaseConnection, DbErr, EntityTrait, ModelTrait,
                QueryFilter,
            };
            use utoipa::openapi::security::{HttpBuilder, SecurityScheme};
            use utoipa::{Modify, OpenApi};
            use utoipa_axum::router::OpenApiRouter;
            use utoipa_axum::routes;
            use utoipa_scalar::{Scalar, Servable};
            use crate::utils::errors::AppError;
            use crate::resources::entities::{refresh_token, users};
            use crate::utils::hash::verify_password;
            use crate::utils::jwt::{
                create_token, validate_jwt_token_without_exp, validate_refresh_token,
            };
            pub struct SecurityAddon;
            impl Modify for SecurityAddon {
                fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
                    if let Some(components) = openapi.components.as_mut() {
                        components
                            .add_security_scheme(
                                "api_jwt_token",
                                SecurityScheme::Http(
                                    HttpBuilder::new()
                                        .scheme(utoipa::openapi::security::HttpAuthScheme::Bearer)
                                        .bearer_format("JWT")
                                        .build(),
                                ),
                            );
                    }
                }
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_login;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_login {
                #[inline]
                fn clone(&self) -> __path_login {
                    __path_login
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_login {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_login {
                fn path() -> String {
                    String::from("/login")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Post].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::APPLICATION_JSON.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!("{0}", <ReqUser as utoipa::ToSchema>::name()),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "200",
                                    utoipa::openapi::ResponseBuilder::new()
                                        .description("")
                                        .content(
                                            "application/json",
                                            utoipa::openapi::content::ContentBuilder::new()
                                                .schema(
                                                    Some(
                                                        utoipa::openapi::schema::RefBuilder::new()
                                                            .ref_location_from_schema_name(
                                                                ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                                                    )
                                                                }),
                                                            ),
                                                    ),
                                                )
                                                .example(
                                                    Some(::serde_json::to_value(&"jwt token").unwrap()),
                                                )
                                                .into(),
                                        )
                                        .build(),
                                )
                                .build(),
                        )
                        .operation_id(Some("login"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_login {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <ReqUser as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <ReqUser as utoipa::PartialSchema>::schema(),
                        ));
                    <ReqUser as utoipa::ToSchema>::schemas(schemas);
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <Tokens as utoipa::PartialSchema>::schema(),
                        ));
                    <Tokens as utoipa::ToSchema>::schemas(schemas);
                }
            }
            pub async fn login(
                State(db): State<DatabaseConnection>,
                Json(request_user): Json<ReqUser>,
            ) -> Result<Json<Tokens>, AppError> {
                let user = users::Entity::find()
                    .filter(users::Column::Username.eq(&request_user.username))
                    .one(&db)
                    .await?;
                match user {
                    Some(user) => {
                        let _ = verify_password(&request_user.password, &user.password)?;
                        let (jwt, refresh) = create_token(
                                user.id,
                                user.username.clone(),
                                &db,
                            )
                            .await?;
                        Ok(
                            Json(Tokens {
                                jwt,
                                refresh,
                                user_info: crate::resources::dto::user::ReadUser {
                                    id: user.id,
                                    username: user.username,
                                },
                            }),
                        )
                    }
                    None => {
                        Err(
                            DbErr::RecordNotFound(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "{0} user name not found!",
                                                request_user.username,
                                            ),
                                        )
                                    }),
                                )
                                .into(),
                        )
                    }
                }
            }
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_login_into_response() {
                #[allow(warnings)]
                #[allow(unreachable_code)]
                #[doc(hidden)]
                async fn __axum_macros_check_login_into_response_make_value() -> Result<
                    Json<Tokens>,
                    AppError,
                > {
                    let State(db): State<DatabaseConnection> = ::core::panicking::panic(
                        "explicit panic",
                    );
                    let Json(request_user): Json<ReqUser> = ::core::panicking::panic(
                        "explicit panic",
                    );
                    {
                        let user = users::Entity::find()
                            .filter(users::Column::Username.eq(&request_user.username))
                            .one(&db)
                            .await?;
                        match user {
                            Some(user) => {
                                let _ = verify_password(
                                    &request_user.password,
                                    &user.password,
                                )?;
                                let (jwt, refresh) = create_token(
                                        user.id,
                                        user.username.clone(),
                                        &db,
                                    )
                                    .await?;
                                Ok(
                                    Json(Tokens {
                                        jwt,
                                        refresh,
                                        user_info: crate::resources::dto::user::ReadUser {
                                            id: user.id,
                                            username: user.username,
                                        },
                                    }),
                                )
                            }
                            None => {
                                Err(
                                    DbErr::RecordNotFound(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0} user name not found!",
                                                        request_user.username,
                                                    ),
                                                )
                                            }),
                                        )
                                        .into(),
                                )
                            }
                        }
                    }
                }
                let value = __axum_macros_check_login_into_response_make_value().await;
                fn check<T>(_: T)
                where
                    T: ::axum::response::IntoResponse,
                {}
                check(value);
            }
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_login_0_from_request_check()
            where
                State<
                    DatabaseConnection,
                >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
            {}
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_login_0_from_request_call_check() {
                __axum_macros_check_login_0_from_request_check();
            }
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_login_1_from_request_check()
            where
                Json<ReqUser>: ::axum::extract::FromRequest<DatabaseConnection> + Send,
            {}
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_login_1_from_request_call_check() {
                __axum_macros_check_login_1_from_request_check();
            }
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            fn __axum_macros_check_login_future() {
                pub async fn login(
                    State(db): State<DatabaseConnection>,
                    Json(request_user): Json<ReqUser>,
                ) -> Result<Json<Tokens>, AppError> {
                    let user = users::Entity::find()
                        .filter(users::Column::Username.eq(&request_user.username))
                        .one(&db)
                        .await?;
                    match user {
                        Some(user) => {
                            let _ = verify_password(
                                &request_user.password,
                                &user.password,
                            )?;
                            let (jwt, refresh) = create_token(
                                    user.id,
                                    user.username.clone(),
                                    &db,
                                )
                                .await?;
                            Ok(
                                Json(Tokens {
                                    jwt,
                                    refresh,
                                    user_info: crate::resources::dto::user::ReadUser {
                                        id: user.id,
                                        username: user.username,
                                    },
                                }),
                            )
                        }
                        None => {
                            Err(
                                DbErr::RecordNotFound(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} user name not found!",
                                                    request_user.username,
                                                ),
                                            )
                                        }),
                                    )
                                    .into(),
                            )
                        }
                    }
                }
                let future = login(
                    ::core::panicking::panic("explicit panic"),
                    ::core::panicking::panic("explicit panic"),
                );
                fn check<T>(_: T)
                where
                    T: ::std::future::Future + Send,
                {}
                check(future);
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_logout;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_logout {
                #[inline]
                fn clone(&self) -> __path_logout {
                    __path_logout
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_logout {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_logout {
                fn path() -> String {
                    String::from("/logout")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Post].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::TEXT_PLAIN.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "200",
                                    utoipa::openapi::ResponseBuilder::new().description(""),
                                )
                                .build(),
                        )
                        .operation_id(Some("logout"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_logout {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {}
            }
            pub async fn logout(
                State(db): State<DatabaseConnection>,
                refresh: String,
            ) -> Result<StatusCode, AppError> {
                let _ = refresh_token::Entity::delete_by_id(refresh).exec(&db).await?;
                Ok(StatusCode::OK)
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_refresh;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_refresh {
                #[inline]
                fn clone(&self) -> __path_refresh {
                    __path_refresh
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_refresh {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_refresh {
                fn path() -> String {
                    String::from("/refresh")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Post].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::APPLICATION_JSON.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "200",
                                    utoipa::openapi::ResponseBuilder::new()
                                        .description("")
                                        .content(
                                            "application/json",
                                            utoipa::openapi::content::ContentBuilder::new()
                                                .schema(
                                                    Some(
                                                        utoipa::openapi::schema::RefBuilder::new()
                                                            .ref_location_from_schema_name(
                                                                ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                                                    )
                                                                }),
                                                            ),
                                                    ),
                                                )
                                                .example(
                                                    Some(::serde_json::to_value(&"jwt, refresh token").unwrap()),
                                                )
                                                .into(),
                                        )
                                        .build(),
                                )
                                .build(),
                        )
                        .operation_id(Some("refresh"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_refresh {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <Tokens as utoipa::PartialSchema>::schema(),
                        ));
                    <Tokens as utoipa::ToSchema>::schemas(schemas);
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <Tokens as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <Tokens as utoipa::PartialSchema>::schema(),
                        ));
                    <Tokens as utoipa::ToSchema>::schemas(schemas);
                }
            }
            async fn refresh(
                State(db): State<DatabaseConnection>,
                Json(tokens): Json<Tokens>,
            ) -> Result<Json<Tokens>, AppError> {
                let jwt_claims = validate_jwt_token_without_exp(&tokens.jwt)?;
                let refresh_claims = validate_refresh_token(&tokens.refresh)?;
                if refresh_claims.user_id != jwt_claims.user_id {
                    return Err(jsonwebtoken::errors::ErrorKind::InvalidSignature.into());
                }
                let user_id = jwt_claims.user_id;
                let username = jwt_claims.username;
                let token_model = refresh_token::Entity::find()
                    .filter(
                        refresh_token::Column::Token
                            .eq(&tokens.refresh)
                            .and(refresh_token::Column::UserId.eq(user_id)),
                    )
                    .one(&db)
                    .await?;
                let now = chrono::Utc::now().naive_utc();
                match token_model {
                    Some(model) => {
                        if now > model.expires_at {
                            return Err(
                                jsonwebtoken::errors::ErrorKind::ExpiredSignature.into(),
                            );
                        }
                        model.delete(&db).await?;
                        let (jwt, refresh) = create_token(user_id, username.clone(), &db)
                            .await?;
                        Ok(
                            Json(Tokens {
                                jwt,
                                refresh,
                                user_info: crate::resources::dto::user::ReadUser {
                                    id: user_id,
                                    username,
                                },
                            }),
                        )
                    }
                    None => Err(jsonwebtoken::errors::ErrorKind::ExpiredSignature.into()),
                }
            }
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_refresh_into_response() {
                #[allow(warnings)]
                #[allow(unreachable_code)]
                #[doc(hidden)]
                async fn __axum_macros_check_refresh_into_response_make_value() -> Result<
                    Json<Tokens>,
                    AppError,
                > {
                    let State(db): State<DatabaseConnection> = ::core::panicking::panic(
                        "explicit panic",
                    );
                    let Json(tokens): Json<Tokens> = ::core::panicking::panic(
                        "explicit panic",
                    );
                    {
                        let jwt_claims = validate_jwt_token_without_exp(&tokens.jwt)?;
                        let refresh_claims = validate_refresh_token(&tokens.refresh)?;
                        if refresh_claims.user_id != jwt_claims.user_id {
                            return Err(
                                jsonwebtoken::errors::ErrorKind::InvalidSignature.into(),
                            );
                        }
                        let user_id = jwt_claims.user_id;
                        let username = jwt_claims.username;
                        let token_model = refresh_token::Entity::find()
                            .filter(
                                refresh_token::Column::Token
                                    .eq(&tokens.refresh)
                                    .and(refresh_token::Column::UserId.eq(user_id)),
                            )
                            .one(&db)
                            .await?;
                        let now = chrono::Utc::now().naive_utc();
                        match token_model {
                            Some(model) => {
                                if now > model.expires_at {
                                    return Err(
                                        jsonwebtoken::errors::ErrorKind::ExpiredSignature.into(),
                                    );
                                }
                                model.delete(&db).await?;
                                let (jwt, refresh) = create_token(
                                        user_id,
                                        username.clone(),
                                        &db,
                                    )
                                    .await?;
                                Ok(
                                    Json(Tokens {
                                        jwt,
                                        refresh,
                                        user_info: crate::resources::dto::user::ReadUser {
                                            id: user_id,
                                            username,
                                        },
                                    }),
                                )
                            }
                            None => {
                                Err(
                                    jsonwebtoken::errors::ErrorKind::ExpiredSignature.into(),
                                )
                            }
                        }
                    }
                }
                let value = __axum_macros_check_refresh_into_response_make_value().await;
                fn check<T>(_: T)
                where
                    T: ::axum::response::IntoResponse,
                {}
                check(value);
            }
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_refresh_0_from_request_check()
            where
                State<
                    DatabaseConnection,
                >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
            {}
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_refresh_0_from_request_call_check() {
                __axum_macros_check_refresh_0_from_request_check();
            }
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_refresh_1_from_request_check()
            where
                Json<Tokens>: ::axum::extract::FromRequest<DatabaseConnection> + Send,
            {}
            #[allow(warnings)]
            #[doc(hidden)]
            fn __axum_macros_check_refresh_1_from_request_call_check() {
                __axum_macros_check_refresh_1_from_request_check();
            }
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            fn __axum_macros_check_refresh_future() {
                async fn refresh(
                    State(db): State<DatabaseConnection>,
                    Json(tokens): Json<Tokens>,
                ) -> Result<Json<Tokens>, AppError> {
                    let jwt_claims = validate_jwt_token_without_exp(&tokens.jwt)?;
                    let refresh_claims = validate_refresh_token(&tokens.refresh)?;
                    if refresh_claims.user_id != jwt_claims.user_id {
                        return Err(
                            jsonwebtoken::errors::ErrorKind::InvalidSignature.into(),
                        );
                    }
                    let user_id = jwt_claims.user_id;
                    let username = jwt_claims.username;
                    let token_model = refresh_token::Entity::find()
                        .filter(
                            refresh_token::Column::Token
                                .eq(&tokens.refresh)
                                .and(refresh_token::Column::UserId.eq(user_id)),
                        )
                        .one(&db)
                        .await?;
                    let now = chrono::Utc::now().naive_utc();
                    match token_model {
                        Some(model) => {
                            if now > model.expires_at {
                                return Err(
                                    jsonwebtoken::errors::ErrorKind::ExpiredSignature.into(),
                                );
                            }
                            model.delete(&db).await?;
                            let (jwt, refresh) = create_token(
                                    user_id,
                                    username.clone(),
                                    &db,
                                )
                                .await?;
                            Ok(
                                Json(Tokens {
                                    jwt,
                                    refresh,
                                    user_info: crate::resources::dto::user::ReadUser {
                                        id: user_id,
                                        username,
                                    },
                                }),
                            )
                        }
                        None => {
                            Err(jsonwebtoken::errors::ErrorKind::ExpiredSignature.into())
                        }
                    }
                }
                let future = refresh(
                    ::core::panicking::panic("explicit panic"),
                    ::core::panicking::panic("explicit panic"),
                );
                fn check<T>(_: T)
                where
                    T: ::std::future::Future + Send,
                {}
                check(future);
            }
            const TAG: &str = "AUTH";
            #[openapi(
                servers((url = "/api/auth", description = "Login API base path")),
                tags((name = TAG, description = "Get JWT Token"))
            )]
            struct ApiDoc;
            impl utoipa::OpenApi for ApiDoc {
                fn openapi() -> utoipa::openapi::OpenApi {
                    use utoipa::{ToSchema, Path};
                    let mut openapi = utoipa::openapi::OpenApiBuilder::new()
                        .info(
                            utoipa::openapi::InfoBuilder::new()
                                .title("fullstack")
                                .version("0.1.0")
                                .description(Some(""))
                                .license(
                                    Some(
                                        utoipa::openapi::info::LicenseBuilder::new()
                                            .name("")
                                            .build(),
                                    ),
                                ),
                        )
                        .paths({ utoipa::openapi::path::PathsBuilder::new() })
                        .tags(
                            Some([
                                utoipa::openapi::tag::TagBuilder::new()
                                    .name(TAG)
                                    .description(Some("Get JWT Token"))
                                    .build(),
                            ]),
                        )
                        .servers(
                            Some([
                                utoipa::openapi::server::ServerBuilder::new()
                                    .url("/api/auth")
                                    .description(Some("Login API base path"))
                                    .build(),
                            ]),
                        )
                        .build();
                    let components = openapi
                        .components
                        .get_or_insert(utoipa::openapi::Components::new());
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    components.schemas.extend(schemas);
                    let _mods: [&dyn utoipa::Modify; 0usize] = [];
                    _mods.iter().for_each(|modifier| modifier.modify(&mut openapi));
                    openapi
                }
            }
            pub fn init_router(aex: AppExtension) -> Router {
                let open_router = OpenApiRouter::new()
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_login::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_login::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_login::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_login::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_login::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), login)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_logout::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_logout::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_logout::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_logout::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_logout::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), logout)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_refresh::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_refresh::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_refresh::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_refresh::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_refresh::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), refresh)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .with_state(aex.db.0.clone());
                let (router, login_api) = open_router.split_for_parts();
                let mut api = ApiDoc::openapi();
                api.merge(login_api);
                let router = router.merge(Scalar::with_url("/doc/scalar", api));
                router
            }
        }
        mod user {
            use crate::resources::dto::fullstack_extension::{AppDatabase, AppExtension};
            use crate::resources::dto::user::{ReadUser, UpsertUser, UserDTO};
            use crate::resources::entities::users;
            use axum::{Extension, Json, Router, extract::{Query, State}};
            use reqwest::StatusCode;
            use sea_orm::{
                ActiveModelTrait, ColumnTrait, Condition, DatabaseConnection, DbErr,
                EntityTrait, QueryFilter, TryIntoModel,
            };
            use utoipa::OpenApi;
            use utoipa_axum::{router::OpenApiRouter, routes};
            use utoipa_scalar::{Scalar, Servable};
            use crate::{
                router::api::auth::SecurityAddon,
                utils::{errors::AppError, hash::hash_password, jwt::CurrentUser},
            };
            trait UserAction {
                async fn update_user(
                    &mut self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError>;
                async fn create_user(
                    &mut self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError>;
                async fn create_user_nonhash(
                    &self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError>;
                async fn get_users(
                    &self,
                    db: &DatabaseConnection,
                ) -> Result<Vec<ReadUser>, AppError>;
                async fn delete_user(
                    self,
                    db: &DatabaseConnection,
                ) -> Result<StatusCode, AppError>;
                fn into_active_model(
                    value: &UpsertUser,
                ) -> Result<users::ActiveModel, AppError>;
            }
            impl UserAction for UpsertUser {
                async fn update_user(
                    &mut self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError> {
                    self.id.ok_or("can't found update target")?;
                    Ok(self.create_user(db).await?.into())
                }
                async fn create_user(
                    &mut self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError> {
                    self.password = Some(
                        hash_password(
                            &self.password.take().ok_or("password is not avalable")?,
                        )?,
                    );
                    self.create_user_nonhash(db).await.into()
                }
                async fn create_user_nonhash(
                    &self,
                    db: &DatabaseConnection,
                ) -> Result<UserDTO, AppError> {
                    let new_user = UpsertUser::into_active_model(self)?;
                    Ok(new_user.save(db).await?.try_into_model()?.into())
                }
                async fn get_users(
                    &self,
                    db: &DatabaseConnection,
                ) -> Result<Vec<ReadUser>, AppError> {
                    let mut condition = Condition::all();
                    if let Some(id) = self.id {
                        condition = condition.add(users::Column::Id.eq(id));
                    }
                    if let Some(username) = self.username.as_ref() {
                        condition = condition
                            .add(
                                users::Column::Username
                                    .like(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("%{0}%", username))
                                        }),
                                    ),
                            );
                    }
                    Ok(
                        users::Entity::find()
                            .filter(condition)
                            .into_model::<ReadUser>()
                            .all(db)
                            .await?,
                    )
                }
                async fn delete_user(
                    self,
                    db: &DatabaseConnection,
                ) -> Result<StatusCode, AppError> {
                    let id = self.id.ok_or("can't found delete target")?;
                    let res = users::Entity::delete_by_id(id)
                        .exec(db)
                        .await?
                        .rows_affected;
                    Ok(
                        if res == 0 {
                            Err("target delete faild")
                        } else {
                            Ok(StatusCode::NO_CONTENT)
                        }?,
                    )
                }
                fn into_active_model(
                    value: &UpsertUser,
                ) -> Result<users::ActiveModel, AppError> {
                    let password = value
                        .password
                        .as_ref()
                        .ok_or("password not input!")?
                        .trim()
                        .to_string();
                    if let Some(id) = value.id {
                        return Ok(users::ActiveModel {
                            id: sea_orm::ActiveValue::Set(id),
                            username: value
                                .username
                                .as_ref()
                                .map(|v| sea_orm::ActiveValue::Set(v.to_string()))
                                .unwrap_or(sea_orm::ActiveValue::NotSet),
                            password: sea_orm::ActiveValue::Set(password),
                        });
                    }
                    let username = value
                        .username
                        .as_ref()
                        .ok_or("user name not input!")?
                        .trim()
                        .to_string();
                    Ok(users::ActiveModel {
                        id: sea_orm::ActiveValue::NotSet,
                        username: sea_orm::ActiveValue::Set(username),
                        password: sea_orm::ActiveValue::Set(password),
                    })
                }
            }
            async fn is_edit_user(
                edit_user_id: &CurrentUser,
                target_user: &UpsertUser,
            ) -> Result<bool, AppError> {
                Ok(
                    *edit_user_id
                        == target_user
                            .id
                            .ok_or(DbErr::RecordNotFound("User not found".to_string()))?,
                )
            }
            const TAG: &str = "USER";
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_post_user;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_post_user {
                #[inline]
                fn clone(&self) -> __path_post_user {
                    __path_post_user
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_post_user {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_post_user {
                fn path() -> String {
                    String::from("/post")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Post].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::APPLICATION_JSON.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "{0}",
                                                                        <UpsertUser as utoipa::ToSchema>::name(),
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "201",
                                    utoipa::openapi::ResponseBuilder::new()
                                        .description("")
                                        .content(
                                            "application/json",
                                            utoipa::openapi::content::ContentBuilder::new()
                                                .schema(
                                                    Some(
                                                        utoipa::openapi::schema::RefBuilder::new()
                                                            .ref_location_from_schema_name(
                                                                ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                                                    )
                                                                }),
                                                            ),
                                                    ),
                                                )
                                                .into(),
                                        )
                                        .build(),
                                )
                                .build(),
                        )
                        .operation_id(Some("post_user"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_post_user {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}",
                                            <UpsertUser as utoipa::ToSchema>::name(),
                                        ),
                                    )
                                }),
                            ),
                            <UpsertUser as utoipa::PartialSchema>::schema(),
                        ));
                    <UpsertUser as utoipa::ToSchema>::schemas(schemas);
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <UserDTO as utoipa::PartialSchema>::schema(),
                        ));
                    <UserDTO as utoipa::ToSchema>::schemas(schemas);
                }
            }
            async fn post_user(
                State(conn): State<DatabaseConnection>,
                Json(mut user): Json<UpsertUser>,
            ) -> Result<(StatusCode, Json<UserDTO>), AppError> {
                Ok((StatusCode::CREATED, Json(user.create_user(&conn).await?)))
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_find_users;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_find_users {
                #[inline]
                fn clone(&self) -> __path_find_users {
                    __path_find_users
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_find_users {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_find_users {
                fn path() -> String {
                    String::from("/get")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Get].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "200",
                                    utoipa::openapi::ResponseBuilder::new()
                                        .description("")
                                        .content(
                                            "application/json",
                                            utoipa::openapi::content::ContentBuilder::new()
                                                .schema(
                                                    Some(
                                                        utoipa::openapi::schema::ArrayBuilder::new()
                                                            .items(
                                                                utoipa::openapi::schema::RefBuilder::new()
                                                                    .ref_location_from_schema_name(
                                                                        ::alloc::__export::must_use({
                                                                            ::alloc::fmt::format(
                                                                                format_args!("{0}", <ReadUser as utoipa::ToSchema>::name()),
                                                                            )
                                                                        }),
                                                                    ),
                                                            ),
                                                    ),
                                                )
                                                .into(),
                                        )
                                        .build(),
                                )
                                .build(),
                        )
                        .securities(
                            Some([
                                utoipa::openapi::security::SecurityRequirement::default()
                                    .add::<&str, [&str; 0usize], &str>("api_jwt_token", []),
                            ]),
                        )
                        .operation_id(Some("find_users"))
                        .parameters(
                            Some(
                                <UpsertUser as utoipa::IntoParams>::into_params(|| Some(
                                    utoipa::openapi::path::ParameterIn::Query,
                                )),
                            ),
                        )
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_find_users {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <ReadUser as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <ReadUser as utoipa::PartialSchema>::schema(),
                        ));
                    <ReadUser as utoipa::ToSchema>::schemas(schemas);
                }
            }
            async fn find_users(
                State(conn): State<DatabaseConnection>,
                Query(user): Query<UpsertUser>,
            ) -> Result<Json<Vec<ReadUser>>, AppError> {
                Ok(Json(user.get_users(&conn).await?))
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_put_user;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_put_user {
                #[inline]
                fn clone(&self) -> __path_put_user {
                    __path_put_user
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_put_user {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_put_user {
                fn path() -> String {
                    String::from("/put")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Put].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::APPLICATION_JSON.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "{0}",
                                                                        <UpsertUser as utoipa::ToSchema>::name(),
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "200",
                                    utoipa::openapi::ResponseBuilder::new()
                                        .description("")
                                        .content(
                                            "application/json",
                                            utoipa::openapi::content::ContentBuilder::new()
                                                .schema(
                                                    Some(
                                                        utoipa::openapi::schema::RefBuilder::new()
                                                            .ref_location_from_schema_name(
                                                                ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                                                    )
                                                                }),
                                                            ),
                                                    ),
                                                )
                                                .into(),
                                        )
                                        .build(),
                                )
                                .build(),
                        )
                        .securities(
                            Some([
                                utoipa::openapi::security::SecurityRequirement::default()
                                    .add::<&str, [&str; 0usize], &str>("api_jwt_token", []),
                            ]),
                        )
                        .operation_id(Some("put_user"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_put_user {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}",
                                            <UpsertUser as utoipa::ToSchema>::name(),
                                        ),
                                    )
                                }),
                            ),
                            <UpsertUser as utoipa::PartialSchema>::schema(),
                        ));
                    <UpsertUser as utoipa::ToSchema>::schemas(schemas);
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <UserDTO as utoipa::PartialSchema>::schema(),
                        ));
                    <UserDTO as utoipa::ToSchema>::schemas(schemas);
                }
            }
            async fn put_user(
                State(conn): State<DatabaseConnection>,
                Extension(id): Extension<CurrentUser>,
                Json(mut user): Json<UpsertUser>,
            ) -> Result<Json<UserDTO>, AppError> {
                Ok(
                    if is_edit_user(&id, &user).await? {
                        Ok(Json(user.update_user(&conn).await?))
                    } else {
                        Err(AppError::auth_error())
                    }?,
                )
            }
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            pub struct __path_delete_user;
            #[automatically_derived]
            #[allow(non_camel_case_types)]
            impl ::core::clone::Clone for __path_delete_user {
                #[inline]
                fn clone(&self) -> __path_delete_user {
                    __path_delete_user
                }
            }
            impl<'t> utoipa::__dev::Tags<'t> for __path_delete_user {
                fn tags() -> Vec<&'t str> {
                    [TAG].into()
                }
            }
            impl utoipa::Path for __path_delete_user {
                fn path() -> String {
                    String::from("/delete")
                }
                fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                    [utoipa::openapi::HttpMethod::Delete].into()
                }
                fn operation() -> utoipa::openapi::path::Operation {
                    use utoipa::openapi::ToArray;
                    use std::iter::FromIterator;
                    utoipa::openapi::path::OperationBuilder::new()
                        .request_body(
                            Some(
                                utoipa::openapi::request_body::RequestBodyBuilder::new()
                                    .content(
                                        mime::APPLICATION_JSON.as_ref(),
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "{0}",
                                                                        <UpsertUser as utoipa::ToSchema>::name(),
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .required(Some(utoipa::openapi::Required::True))
                                    .build(),
                            ),
                        )
                        .responses(
                            utoipa::openapi::ResponsesBuilder::new()
                                .response(
                                    "204",
                                    utoipa::openapi::ResponseBuilder::new().description(""),
                                )
                                .build(),
                        )
                        .securities(
                            Some([
                                utoipa::openapi::security::SecurityRequirement::default()
                                    .add::<&str, [&str; 0usize], &str>("api_jwt_token", []),
                            ]),
                        )
                        .operation_id(Some("delete_user"))
                        .into()
                }
            }
            impl utoipa::__dev::SchemaReferences for __path_delete_user {
                fn schemas(
                    schemas: &mut Vec<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >,
                ) {
                    schemas
                        .push((
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}",
                                            <UpsertUser as utoipa::ToSchema>::name(),
                                        ),
                                    )
                                }),
                            ),
                            <UpsertUser as utoipa::PartialSchema>::schema(),
                        ));
                    <UpsertUser as utoipa::ToSchema>::schemas(schemas);
                }
            }
            async fn delete_user(
                State(conn): State<DatabaseConnection>,
                Extension(id): Extension<CurrentUser>,
                Json(user): Json<UpsertUser>,
            ) -> Result<StatusCode, AppError> {
                Ok(
                    if is_edit_user(&id, &user).await? {
                        Ok(user.delete_user(&conn).await?)
                    } else {
                        Err(AppError::auth_error())
                    }?,
                )
            }
            #[openapi(
                servers((url = "/api/user", description = "User API base path")),
                modifiers(&SecurityAddon),
                tags((name = TAG, description = "User handler management API"))
            )]
            pub(super) struct ApiDoc;
            impl utoipa::OpenApi for ApiDoc {
                fn openapi() -> utoipa::openapi::OpenApi {
                    use utoipa::{ToSchema, Path};
                    let mut openapi = utoipa::openapi::OpenApiBuilder::new()
                        .info(
                            utoipa::openapi::InfoBuilder::new()
                                .title("fullstack")
                                .version("0.1.0")
                                .description(Some(""))
                                .license(
                                    Some(
                                        utoipa::openapi::info::LicenseBuilder::new()
                                            .name("")
                                            .build(),
                                    ),
                                ),
                        )
                        .paths({ utoipa::openapi::path::PathsBuilder::new() })
                        .tags(
                            Some([
                                utoipa::openapi::tag::TagBuilder::new()
                                    .name(TAG)
                                    .description(Some("User handler management API"))
                                    .build(),
                            ]),
                        )
                        .servers(
                            Some([
                                utoipa::openapi::server::ServerBuilder::new()
                                    .url("/api/user")
                                    .description(Some("User API base path"))
                                    .build(),
                            ]),
                        )
                        .build();
                    let components = openapi
                        .components
                        .get_or_insert(utoipa::openapi::Components::new());
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    components.schemas.extend(schemas);
                    let _mods: [&dyn utoipa::Modify; 1usize] = [&SecurityAddon];
                    _mods.iter().for_each(|modifier| modifier.modify(&mut openapi));
                    openapi
                }
            }
            pub(super) fn init_route(aex: AppExtension) -> (Router, Router) {
                let auth_router = OpenApiRouter::new()
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_find_users::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_find_users::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_find_users::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_find_users::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_find_users::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), find_users)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_put_user::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_put_user::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_put_user::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_put_user::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_put_user::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), put_user)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_delete_user::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_delete_user::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_delete_user::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_delete_user::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_delete_user::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), delete_user)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .with_state(aex.db.0.clone());
                let unauth_router = OpenApiRouter::new()
                    .routes({
                        use ::utoipa_axum::PathItemExt;
                        let mut paths = utoipa::openapi::path::Paths::new();
                        let mut schemas = Vec::<
                            (
                                String,
                                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                            ),
                        >::new();
                        let (path, item, types) = {
                            let path = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_post_user::path()
                            };
                            let mut operation = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_post_user::operation()
                            };
                            let types = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_post_user::methods()
                            };
                            let tags = {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_post_user::tags()
                            };
                            {
                                #[allow(unused_imports)]
                                use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                                __path_post_user::schemas(&mut schemas)
                            };
                            if !tags.is_empty() {
                                let operation_tags = operation
                                    .tags
                                    .get_or_insert(Vec::new());
                                operation_tags.extend(tags.iter().map(ToString::to_string));
                            }
                            (path, operation, types)
                        };
                        #[allow(unused_mut)]
                        let mut method_router = types
                            .iter()
                            .by_ref()
                            .fold(
                                axum::routing::MethodRouter::new(),
                                |router, path_type| {
                                    router.on(path_type.to_method_filter(), post_user)
                                },
                            );
                        paths.add_path_operation(&path, types, item);
                        (schemas, paths, method_router)
                    })
                    .with_state(aex.db.0);
                let (auth_router, auth_api) = auth_router.split_for_parts();
                let (unauth_router, unauth_api) = unauth_router.split_for_parts();
                let mut api = ApiDoc::openapi();
                api.merge(auth_api);
                api.merge(unauth_api);
                let unauth_router = unauth_router
                    .merge(Scalar::with_url("/doc/scalar", api));
                (
                    Router::new().nest("/user", auth_router),
                    Router::new().nest("/user", unauth_router),
                )
            }
        }
        pub struct ApiRouters {
            pub auth: Router,
            pub unauth: Router,
        }
        impl ApiRouters {
            pub fn new_nest(self, url: &str) -> Self {
                Self {
                    auth: Router::new().nest(url, self.auth),
                    unauth: Router::new().nest(url, self.unauth),
                }
            }
            pub fn merge(self, other: Self) -> Self {
                Self {
                    auth: self.auth.merge(other.auth),
                    unauth: self.unauth.merge(other.unauth),
                }
            }
            pub fn nest(self, other: Self, url: &str) -> Self {
                Self {
                    auth: self.auth.nest(url, other.auth),
                    unauth: self.unauth.nest(url, other.unauth),
                }
            }
        }
        impl From<(Router, Router)> for ApiRouters {
            fn from(value: (Router, Router)) -> Self {
                ApiRouters {
                    auth: value.0,
                    unauth: value.1,
                }
            }
        }
        pub fn init_route(aex: AppExtension) -> ApiRouters {
            ApiRouters::from(user::init_route(aex)).new_nest("/api")
        }
    }
    pub mod hello {
        mod database {
            use crate::resources::entities::*;
            use crate::utils::errors::AppError;
            use reqwest::StatusCode;
            use sea_orm::{
                ActiveModelTrait, ActiveValue::{self, NotSet, Set},
                ColumnTrait, Condition, DatabaseConnection, EntityTrait, InsertResult,
                IntoActiveModel, QueryFilter, QueryOrder, QuerySelect, UpdateResult,
                prelude::Expr,
            };
            pub async fn hello_select_one(
                conn: &DatabaseConnection,
                id: i32,
            ) -> Result<users::Model, AppError> {
                let user = users::Entity::find_by_id(id).one(conn).await?;
                if let Some(user) = user {
                    return Ok(user);
                }
                Err(AppError::new(StatusCode::BAD_REQUEST, "Can't find user id"))
            }
            pub async fn hello_select_all(
                conn: &DatabaseConnection,
                filter: Condition,
                limit: Option<u64>,
            ) -> Result<Vec<users::Model>, AppError> {
                let mut condition = Condition::all();
                condition = condition.add(filter);
                let mut user = users::Entity::find()
                    .filter(condition)
                    .order_by_asc(users::Column::Username);
                if let Some(limit) = limit {
                    user = user.limit(limit);
                }
                let user = user.all(conn).await?;
                Ok(user)
            }
            pub async fn hello_insert_one1(
                conn: &DatabaseConnection,
                username: String,
                password: String,
            ) -> Result<users::Model, AppError> {
                let new_user = users::ActiveModel {
                    id: NotSet,
                    username: Set(username),
                    password: Set(password),
                }
                    .insert(conn)
                    .await?;
                Ok(new_user)
            }
            pub async fn hello_insert_one2(
                conn: &DatabaseConnection,
                username: String,
                password: String,
            ) -> Result<InsertResult<users::ActiveModel>, AppError> {
                let new_user = users::ActiveModel {
                    id: NotSet,
                    username: Set(username),
                    password: Set(password),
                };
                let result = users::Entity::insert(new_user).exec(conn).await?;
                Ok(result)
            }
            pub async fn hello_insert_many(
                conn: &DatabaseConnection,
                data: Vec<(String, String)>,
            ) -> Result<InsertResult<users::ActiveModel>, AppError> {
                let new_users = data
                    .into_iter()
                    .map(|(name, pass)| users::ActiveModel {
                        id: NotSet,
                        username: Set(name),
                        password: Set(pass),
                    });
                let result = users::Entity::insert_many(new_users).exec(conn).await?;
                let last_id = result.last_insert_id;
                {
                    ::std::io::_print(format_args!("last id is {0}\n", last_id));
                };
                Ok(result)
            }
            pub async fn hello_update_one1(
                conn: &DatabaseConnection,
                id: i32,
                change_name: String,
                change_password: String,
            ) -> Result<users::Model, AppError> {
                let user = users::Entity::find_by_id(id).one(conn).await?;
                if let Some(user) = user {
                    let mut user = user.into_active_model();
                    user.username = ActiveValue::Set(change_name);
                    user.password = ActiveValue::Set(change_password);
                    let updated_user = user.update(conn).await?;
                    return Ok(updated_user);
                }
                Err(AppError::new(StatusCode::BAD_REQUEST, "Can't find user"))
            }
            pub async fn hello_update_one2(
                conn: &DatabaseConnection,
                model: users::Model,
                change_name: String,
                change_password: String,
            ) -> Result<users::Model, AppError> {
                let mut user = model.into_active_model();
                user.username = ActiveValue::Set(change_name);
                user.password = ActiveValue::Set(change_password);
                let updated_user = user.update(conn).await?;
                Ok(updated_user)
            }
            pub async fn hello_update_many(
                conn: &DatabaseConnection,
                change_name: String,
                change_password: String,
            ) -> Result<UpdateResult, AppError> {
                let updated_user = users::Entity::update_many()
                    .col_expr(users::Column::Password, Expr::value(change_name))
                    .col_expr(users::Column::Username, Expr::value(change_password))
                    .exec(conn)
                    .await?;
                Ok(updated_user)
            }
            pub async fn hello_delete_by_model(
                conn: &DatabaseConnection,
                model: users::Model,
            ) -> Result<sea_orm::DeleteResult, AppError> {
                let delete_user = users::Entity::delete_many()
                    .filter(
                        users::Column::Username
                            .eq(model.username)
                            .and(users::Column::Password.eq(model.password)),
                    )
                    .exec(conn)
                    .await?;
                if delete_user.rows_affected == 0 {
                    return Err(AppError::new(StatusCode::NOT_FOUND, "User not found"));
                }
                Ok(delete_user)
            }
            pub async fn hello_delete_by_id(
                conn: &DatabaseConnection,
                id: i32,
            ) -> Result<sea_orm::DeleteResult, AppError> {
                let delete_user = users::Entity::delete_by_id(id).exec(conn).await?;
                if delete_user.rows_affected == 0 {
                    return Err(AppError::new(StatusCode::NOT_FOUND, "User not found"));
                }
                Ok(delete_user)
            }
            pub async fn hello_delete_many(
                conn: &DatabaseConnection,
            ) -> Result<sea_orm::DeleteResult, AppError> {
                let delete_users = users::Entity::delete_many().exec(conn).await?;
                Ok(delete_users)
            }
        }
        mod open_api {
            use axum::Router;
            use utoipa::{
                Modify, OpenApi, openapi::security::{ApiKey, ApiKeyValue, SecurityScheme},
            };
            use utoipa_axum::router::OpenApiRouter;
            use utoipa_scalar::{Scalar, Servable as ScalarServable};
            pub(super) const HELLO_TAG: &str = "hello";
            #[openapi(
                servers((url = "/hello", description = "Hello API base path")),
                modifiers(&SecurityAddon),
                tags((name = HELLO_TAG, description = "Hello handler management API"))
            )]
            pub(super) struct ApiDoc;
            impl utoipa::OpenApi for ApiDoc {
                fn openapi() -> utoipa::openapi::OpenApi {
                    use utoipa::{ToSchema, Path};
                    let mut openapi = utoipa::openapi::OpenApiBuilder::new()
                        .info(
                            utoipa::openapi::InfoBuilder::new()
                                .title("fullstack")
                                .version("0.1.0")
                                .description(Some(""))
                                .license(
                                    Some(
                                        utoipa::openapi::info::LicenseBuilder::new()
                                            .name("")
                                            .build(),
                                    ),
                                ),
                        )
                        .paths({ utoipa::openapi::path::PathsBuilder::new() })
                        .tags(
                            Some([
                                utoipa::openapi::tag::TagBuilder::new()
                                    .name(HELLO_TAG)
                                    .description(Some("Hello handler management API"))
                                    .build(),
                            ]),
                        )
                        .servers(
                            Some([
                                utoipa::openapi::server::ServerBuilder::new()
                                    .url("/hello")
                                    .description(Some("Hello API base path"))
                                    .build(),
                            ]),
                        )
                        .build();
                    let components = openapi
                        .components
                        .get_or_insert(utoipa::openapi::Components::new());
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    components.schemas.extend(schemas);
                    let _mods: [&dyn utoipa::Modify; 1usize] = [&SecurityAddon];
                    _mods.iter().for_each(|modifier| modifier.modify(&mut openapi));
                    openapi
                }
            }
            struct SecurityAddon;
            impl Modify for SecurityAddon {
                fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
                    if let Some(components) = openapi.components.as_mut() {
                        components
                            .add_security_scheme(
                                "api_key",
                                SecurityScheme::ApiKey(
                                    ApiKey::Header(ApiKeyValue::new("hello_apikey")),
                                ),
                            );
                    }
                }
            }
            pub(super) fn set_router(base_router: OpenApiRouter) -> Router {
                let (router, api) = OpenApiRouter::with_openapi(ApiDoc::openapi())
                    .nest("/hello", base_router)
                    .split_for_parts();
                let router = router.merge(Scalar::with_url("/scalar", api));
                router
            }
        }
        pub mod state {
            use std::{collections::HashMap, sync::Arc};
            use axum::{body::Bytes, extract::FromRef};
            use reqwest::Client;
            use sea_orm::DatabaseConnection;
            use tokio::sync::Mutex;
            fn get_base_state() -> Arc<Mutex<Vec<i32>>> {
                Arc::new(Mutex::new(::alloc::vec::from_elem(0, 3)))
            }
            pub struct HelloAppState {
                pub auth_token: String,
                pub current_users: i32,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HelloAppState {
                #[inline]
                fn clone(&self) -> HelloAppState {
                    HelloAppState {
                        auth_token: ::core::clone::Clone::clone(&self.auth_token),
                        current_users: ::core::clone::Clone::clone(&self.current_users),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for HelloAppState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "HelloAppState",
                        "auth_token",
                        &self.auth_token,
                        "current_users",
                        &&self.current_users,
                    )
                }
            }
            pub fn get_hello_app_state() -> HelloAppState {
                HelloAppState {
                    auth_token: "auth_token".to_string(),
                    current_users: 3,
                }
            }
            fn get_proxy_state() -> Arc<Mutex<HashMap<String, (Bytes, usize)>>> {
                Arc::new(Mutex::new(HashMap::new()))
            }
            pub struct HelloState {
                hello_app_state: HelloAppState,
                base_state: Arc<Mutex<Vec<i32>>>,
                proxy_state: Arc<Mutex<HashMap<String, (Bytes, usize)>>>,
                pool: DatabaseConnection,
                client: Client,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HelloState {
                #[inline]
                fn clone(&self) -> HelloState {
                    HelloState {
                        hello_app_state: ::core::clone::Clone::clone(
                            &self.hello_app_state,
                        ),
                        base_state: ::core::clone::Clone::clone(&self.base_state),
                        proxy_state: ::core::clone::Clone::clone(&self.proxy_state),
                        pool: ::core::clone::Clone::clone(&self.pool),
                        client: ::core::clone::Clone::clone(&self.client),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for HelloState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "HelloState",
                        "hello_app_state",
                        &self.hello_app_state,
                        "base_state",
                        &self.base_state,
                        "proxy_state",
                        &self.proxy_state,
                        "pool",
                        &self.pool,
                        "client",
                        &&self.client,
                    )
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<HelloState> for HelloAppState {
                fn from_ref(state: &HelloState) -> Self {
                    state.hello_app_state.clone()
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<HelloState> for Arc<Mutex<Vec<i32>>> {
                fn from_ref(state: &HelloState) -> Self {
                    state.base_state.clone()
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<HelloState>
            for Arc<Mutex<HashMap<String, (Bytes, usize)>>> {
                fn from_ref(state: &HelloState) -> Self {
                    state.proxy_state.clone()
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<HelloState> for DatabaseConnection {
                fn from_ref(state: &HelloState) -> Self {
                    state.pool.clone()
                }
            }
            #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
            impl ::axum::extract::FromRef<HelloState> for Client {
                fn from_ref(state: &HelloState) -> Self {
                    state.client.clone()
                }
            }
            pub fn get_hello_state(pool: DatabaseConnection) -> HelloState {
                HelloState {
                    hello_app_state: get_hello_app_state(),
                    base_state: get_base_state(),
                    proxy_state: get_proxy_state(),
                    client: Client::new(),
                    pool,
                }
            }
        }
        use std::{collections::HashMap, sync::Arc};
        use crate::resources::dto::{fullstack_extension::AppExtension, user::UserDTO};
        use axum::{
            Extension, Form, Json, Router, body::Bytes, debug_handler,
            extract::{Multipart, Path, Query, State},
            http::{
                HeaderMap, HeaderValue, StatusCode, header::{CONTENT_TYPE, USER_AGENT},
            },
        };
        use axum_extra::{TypedHeader, headers::{ContentType, UserAgent}};
        use reqwest::Client;
        use sea_orm::{ColumnTrait, Condition, DatabaseConnection};
        use serde::{Deserialize, Serialize};
        use std::fmt::Write;
        use tokio::sync::Mutex;
        use utoipa::{IntoParams, ToSchema};
        use utoipa_axum::{router::OpenApiRouter, routes};
        use crate::resources::entities::users;
        use state::*;
        use crate::{
            router::hello::{
                database::{
                    hello_delete_by_id, hello_delete_by_model, hello_delete_many,
                    hello_insert_many, hello_insert_one1, hello_insert_one2,
                    hello_select_all, hello_select_one, hello_update_many,
                    hello_update_one1, hello_update_one2,
                },
                open_api::{HELLO_TAG, set_router},
            },
            utils::errors::AppError,
        };
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_path_query;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_path_query {
            #[inline]
            fn clone(&self) -> __path_path_query {
                __path_path_query
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_path_query {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_path_query {
            fn path() -> String {
                String::from("/path/{id}/{name}")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get id(i32) name(String), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"1 : dolto").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("path_query"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("id"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Path)
                            .description(Some("numeric id"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::Integer,
                                            ),
                                        )
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("name"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Path)
                            .description(Some("user name"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_path_query {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn path_query(Path((id, name)): Path<(i32, String)>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("{0} : {1}\n", id, name))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_path_query_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_path_query_into_response_make_value() -> String {
                let Path((id, name)): Path<(i32, String)> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("{0} : {1}\n", id, name))
                    })
                }
            }
            let value = __axum_macros_check_path_query_into_response_make_value().await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_path_query_0_from_request_check<M>()
        where
            Path<(i32, String)>: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_path_query_0_from_request_call_check() {
            __axum_macros_check_path_query_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_path_query_future() {
            async fn path_query(Path((id, name)): Path<(i32, String)>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("{0} : {1}\n", id, name))
                })
            }
            let future = path_query(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_param_query_with_hashmap;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_param_query_with_hashmap {
            #[inline]
            fn clone(&self) -> __path_param_query_with_hashmap {
                __path_param_query_with_hashmap
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_param_query_with_hashmap {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_param_query_with_hashmap {
            fn path() -> String {
                String::from("/param1")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get id(String) name(String), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"d : dolto").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("param_query_with_hashmap"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("id"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Query)
                            .description(Some("user id"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::False),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("name"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Query)
                            .description(Some("user name"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::False),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_param_query_with_hashmap {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn param_query_with_hashmap(
            Query(user): Query<HashMap<String, String>>,
        ) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0} : {1}\n",
                        user.get("id").map_or("Id is Not Input", String::as_str),
                        user
                            .get("name")
                            .map(String::as_str)
                            .unwrap_or("Name is Not Input"),
                    ),
                )
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_param_query_with_hashmap_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_param_query_with_hashmap_into_response_make_value() -> String {
                let Query(user): Query<HashMap<String, String>> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0} : {1}\n",
                                user.get("id").map_or("Id is Not Input", String::as_str),
                                user
                                    .get("name")
                                    .map(String::as_str)
                                    .unwrap_or("Name is Not Input"),
                            ),
                        )
                    })
                }
            }
            let value = __axum_macros_check_param_query_with_hashmap_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_hashmap_0_from_request_check<M>()
        where
            Query<HashMap<String, String>>: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_hashmap_0_from_request_call_check() {
            __axum_macros_check_param_query_with_hashmap_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_hashmap_future() {
            async fn param_query_with_hashmap(
                Query(user): Query<HashMap<String, String>>,
            ) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0} : {1}\n",
                            user.get("id").map_or("Id is Not Input", String::as_str),
                            user
                                .get("name")
                                .map(String::as_str)
                                .unwrap_or("Name is Not Input"),
                        ),
                    )
                })
            }
            let future = param_query_with_hashmap(
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct User {
            id: i32,
            name: Option<String>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for User {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private228::Ok(__Field::__field0),
                                "name" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private228::Ok(__Field::__field0),
                                b"name" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<User>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = User;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct User",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct User with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct User with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(User {
                                id: __field0,
                                name: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<i32> = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<
                                Option<String>,
                            > = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("name")?
                                }
                            };
                            _serde::__private228::Ok(User {
                                id: __field0,
                                name: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["id", "name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "User",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<User>,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::IntoParams for User {
            fn into_params(
                parameter_in_provider: impl Fn(
                ) -> Option<utoipa::openapi::path::ParameterIn>,
            ) -> Vec<utoipa::openapi::path::Parameter> {
                [
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("id")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::True)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::Integer,
                                            ),
                                        )
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("name")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::String,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        }),
                                ),
                            )
                            .build(),
                    ),
                ]
                    .into_iter()
                    .filter(Option::is_some)
                    .flatten()
                    .collect()
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_param_query_with_struct;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_param_query_with_struct {
            #[inline]
            fn clone(&self) -> __path_param_query_with_struct {
                __path_param_query_with_struct
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_param_query_with_struct {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_param_query_with_struct {
            fn path() -> String {
                String::from("/param2")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get id(String) name(String), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"d : dolto").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("param_query_with_struct"))
                    .parameters(
                        Some(
                            <User as utoipa::IntoParams>::into_params(|| Some(
                                utoipa::openapi::path::ParameterIn::Query,
                            )),
                        ),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_param_query_with_struct {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn param_query_with_struct(Query(user): Query<User>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0} : {1}\n",
                        user.id,
                        user.name.as_deref().unwrap_or("No name"),
                    ),
                )
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_param_query_with_struct_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_param_query_with_struct_into_response_make_value() -> String {
                let Query(user): Query<User> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0} : {1}\n",
                                user.id,
                                user.name.as_deref().unwrap_or("No name"),
                            ),
                        )
                    })
                }
            }
            let value = __axum_macros_check_param_query_with_struct_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_struct_0_from_request_check<M>()
        where
            Query<User>: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_struct_0_from_request_call_check() {
            __axum_macros_check_param_query_with_struct_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_param_query_with_struct_future() {
            async fn param_query_with_struct(Query(user): Query<User>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0} : {1}\n",
                            user.id,
                            user.name.as_deref().unwrap_or("No name"),
                        ),
                    )
                })
            }
            let future = param_query_with_struct(
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_body_query_text;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_body_query_text {
            #[inline]
            fn clone(&self) -> __path_body_query_text {
                __path_body_query_text
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_body_query_text {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_body_query_text {
            fn path() -> String {
                String::from("/text")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    "text/plain",
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::ObjectBuilder::new()
                                                    .schema_type(
                                                        utoipa::openapi::schema::SchemaType::new(
                                                            utoipa::openapi::schema::Type::String,
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("get String"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get name(String), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello dolto\n").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("body_query_text"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_body_query_text {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn body_query_text(name: String) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("Hello {0}\n", name))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_body_query_text_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_body_query_text_into_response_make_value() -> String {
                let name: String = ::core::panicking::panic("explicit panic");
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Hello {0}\n", name))
                    })
                }
            }
            let value = __axum_macros_check_body_query_text_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_text_0_from_request_check()
        where
            String: ::axum::extract::FromRequest<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_text_0_from_request_call_check() {
            __axum_macros_check_body_query_text_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_text_future() {
            async fn body_query_text(name: String) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("Hello {0}\n", name))
                })
            }
            let future = body_query_text(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_body_query_bytes;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_body_query_bytes {
            #[inline]
            fn clone(&self) -> __path_body_query_bytes {
                __path_body_query_bytes
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_body_query_bytes {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_body_query_bytes {
            fn path() -> String {
                String::from("/bytes")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    "text/plain",
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::ObjectBuilder::new()
                                                    .schema_type(
                                                        utoipa::openapi::schema::SchemaType::new(
                                                            utoipa::openapi::schema::Type::String,
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("get Bytes"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get name(Bytes), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello dolto\n").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("body_query_bytes"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_body_query_bytes {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn body_query_bytes(name: Bytes) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("Hello {0}\n", String::from_utf8_lossy(&name)),
                )
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_body_query_bytes_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_body_query_bytes_into_response_make_value() -> String {
                let name: Bytes = ::core::panicking::panic("explicit panic");
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Hello {0}\n", String::from_utf8_lossy(&name)),
                        )
                    })
                }
            }
            let value = __axum_macros_check_body_query_bytes_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_bytes_0_from_request_check()
        where
            Bytes: ::axum::extract::FromRequest<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_bytes_0_from_request_call_check() {
            __axum_macros_check_body_query_bytes_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_bytes_future() {
            async fn body_query_bytes(name: Bytes) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("Hello {0}\n", String::from_utf8_lossy(&name)),
                    )
                })
            }
            let future = body_query_bytes(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct TestJson {
            name: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TestJson {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private228::Ok(__Field::__field0),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private228::Ok(__Field::__field0),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<TestJson>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TestJson;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct TestJson",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TestJson with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(TestJson { name: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("name")?
                                }
                            };
                            _serde::__private228::Ok(TestJson { name: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TestJson",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<TestJson>,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for TestJson {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "name",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                ),
                        )
                        .required("name");
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for TestJson {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TestJson")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_body_query_json;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_body_query_json {
            #[inline]
            fn clone(&self) -> __path_body_query_json {
                __path_body_query_json
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_body_query_json {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_body_query_json {
            fn path() -> String {
                String::from("/json")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::APPLICATION_JSON.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::RefBuilder::new()
                                                    .ref_location_from_schema_name(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0}", <TestJson as utoipa::ToSchema>::name()),
                                                            )
                                                        }),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("get Json"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get name(Json), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello dolto\n").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("body_query_json"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_body_query_json {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", <TestJson as utoipa::ToSchema>::name()),
                                )
                            }),
                        ),
                        <TestJson as utoipa::PartialSchema>::schema(),
                    ));
                <TestJson as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn body_query_json(Json(user): Json<TestJson>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_body_query_json_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_body_query_json_into_response_make_value() -> String {
                let Json(user): Json<TestJson> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
                    })
                }
            }
            let value = __axum_macros_check_body_query_json_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_json_0_from_request_check()
        where
            Json<TestJson>: ::axum::extract::FromRequest<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_json_0_from_request_call_check() {
            __axum_macros_check_body_query_json_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_json_future() {
            async fn body_query_json(Json(user): Json<TestJson>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
                })
            }
            let future = body_query_json(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_body_query_form;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_body_query_form {
            #[inline]
            fn clone(&self) -> __path_body_query_form {
                __path_body_query_form
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_body_query_form {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_body_query_form {
            fn path() -> String {
                String::from("/form")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::WWW_FORM_URLENCODED.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::RefBuilder::new()
                                                    .ref_location_from_schema_name(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0}", <TestJson as utoipa::ToSchema>::name()),
                                                            )
                                                        }),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("get form"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get name(Form), and print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello dolto\n").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("body_query_form"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_body_query_form {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", <TestJson as utoipa::ToSchema>::name()),
                                )
                            }),
                        ),
                        <TestJson as utoipa::PartialSchema>::schema(),
                    ));
                <TestJson as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn body_query_form(Form(user): Form<TestJson>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_body_query_form_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_body_query_form_into_response_make_value() -> String {
                let Form(user): Form<TestJson> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
                    })
                }
            }
            let value = __axum_macros_check_body_query_form_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_form_0_from_request_check()
        where
            Form<TestJson>: ::axum::extract::FromRequest<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_form_0_from_request_call_check() {
            __axum_macros_check_body_query_form_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_form_future() {
            async fn body_query_form(Form(user): Form<TestJson>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("Hello {0}\n", user.name))
                })
            }
            let future = body_query_form(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_body_query_file_upload;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_body_query_file_upload {
            #[inline]
            fn clone(&self) -> __path_body_query_file_upload {
                __path_body_query_file_upload
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_body_query_file_upload {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_body_query_file_upload {
            fn path() -> String {
                String::from("/file")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::MULTIPART_FORM_DATA.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::ArrayBuilder::new()
                                                    .items(
                                                        utoipa::openapi::ObjectBuilder::new()
                                                            .schema_type(
                                                                utoipa::openapi::schema::SchemaType::new(
                                                                    utoipa::openapi::schema::Type::Integer,
                                                                ),
                                                            )
                                                            .format(
                                                                Some(
                                                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                                        utoipa::openapi::schema::KnownFormat::Int32,
                                                                    ),
                                                                ),
                                                            )
                                                            .minimum(Some(0f64)),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("get File"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get file, and name : length print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"file_name : 1002").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("body_query_file_upload"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_body_query_file_upload {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn body_query_file_upload(mut body: Multipart) -> String {
            let mut result = String::new();
            while let Ok(Some(mut field)) = body.next_field().await {
                let name = field.name().unwrap_or("unknown").to_string();
                let mut bytes = 0;
                while let Ok(Some(chunk)) = field.chunk().await {
                    bytes += chunk.len();
                }
                (&mut result)
                    .write_fmt(format_args!("{0} : {1}\n", name, bytes))
                    .unwrap();
            }
            result
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_body_query_file_upload_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_body_query_file_upload_into_response_make_value() -> String {
                let mut body: Multipart = ::core::panicking::panic("explicit panic");
                {
                    let mut result = String::new();
                    while let Ok(Some(mut field)) = body.next_field().await {
                        let name = field.name().unwrap_or("unknown").to_string();
                        let mut bytes = 0;
                        while let Ok(Some(chunk)) = field.chunk().await {
                            bytes += chunk.len();
                        }
                        (&mut result)
                            .write_fmt(format_args!("{0} : {1}\n", name, bytes))
                            .unwrap();
                    }
                    result
                }
            }
            let value = __axum_macros_check_body_query_file_upload_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_file_upload_0_from_request_check()
        where
            Multipart: ::axum::extract::FromRequest<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_file_upload_0_from_request_call_check() {
            __axum_macros_check_body_query_file_upload_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_body_query_file_upload_future() {
            async fn body_query_file_upload(mut body: Multipart) -> String {
                let mut result = String::new();
                while let Ok(Some(mut field)) = body.next_field().await {
                    let name = field.name().unwrap_or("unknown").to_string();
                    let mut bytes = 0;
                    while let Ok(Some(chunk)) = field.chunk().await {
                        bytes += chunk.len();
                    }
                    (&mut result)
                        .write_fmt(format_args!("{0} : {1}\n", name, bytes))
                        .unwrap();
                }
                result
            }
            let future = body_query_file_upload(
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_header_hello1;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_header_hello1 {
            #[inline]
            fn clone(&self) -> __path_header_hello1 {
                __path_header_hello1
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_header_hello1 {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_header_hello1 {
            fn path() -> String {
                String::from("/header1")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get file, and name : length print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(
                                                    ::serde_json::to_value(&"User-Agent: , Content-Type: ")
                                                        .unwrap(),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("header_hello1"))
                    .description(Some("Use HeaderMap"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("User-Agent"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .description(Some("User agent header"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("Content-Type"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .description(Some("Content type header"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_header_hello1 {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn header_hello1(headers: HeaderMap) -> String {
            let user_agent = headers
                .get(USER_AGENT)
                .map(|v| v.to_owned())
                .unwrap_or(HeaderValue::from_name(USER_AGENT));
            let content_type = headers
                .get(CONTENT_TYPE)
                .map(|v| v.to_owned())
                .unwrap_or(HeaderValue::from_name(CONTENT_TYPE));
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "User-Agent: {0:?}, Content-Type: {1:?}\n",
                        user_agent,
                        content_type,
                    ),
                )
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_header_hello1_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_header_hello1_into_response_make_value() -> String {
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                {
                    let user_agent = headers
                        .get(USER_AGENT)
                        .map(|v| v.to_owned())
                        .unwrap_or(HeaderValue::from_name(USER_AGENT));
                    let content_type = headers
                        .get(CONTENT_TYPE)
                        .map(|v| v.to_owned())
                        .unwrap_or(HeaderValue::from_name(CONTENT_TYPE));
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "User-Agent: {0:?}, Content-Type: {1:?}\n",
                                user_agent,
                                content_type,
                            ),
                        )
                    })
                }
            }
            let value = __axum_macros_check_header_hello1_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello1_0_from_request_check<M>()
        where
            HeaderMap: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello1_0_from_request_call_check() {
            __axum_macros_check_header_hello1_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello1_future() {
            async fn header_hello1(headers: HeaderMap) -> String {
                let user_agent = headers
                    .get(USER_AGENT)
                    .map(|v| v.to_owned())
                    .unwrap_or(HeaderValue::from_name(USER_AGENT));
                let content_type = headers
                    .get(CONTENT_TYPE)
                    .map(|v| v.to_owned())
                    .unwrap_or(HeaderValue::from_name(CONTENT_TYPE));
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "User-Agent: {0:?}, Content-Type: {1:?}\n",
                            user_agent,
                            content_type,
                        ),
                    )
                })
            }
            let future = header_hello1(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_header_hello2;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_header_hello2 {
            #[inline]
            fn clone(&self) -> __path_header_hello2 {
                __path_header_hello2
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_header_hello2 {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_header_hello2 {
            fn path() -> String {
                String::from("/header2")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("get file, and name : length print")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(
                                                    ::serde_json::to_value(&"User-Agent: , Content-Type: ")
                                                        .unwrap(),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("header_hello2"))
                    .description(Some("Use TypeHeader (axum-extra)"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("User-Agent"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .description(Some("User agent header"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("Content-Type"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .description(Some("Content type header"))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_header_hello2 {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn header_hello2(
            user_agent: TypedHeader<UserAgent>,
            content_type: Option<TypedHeader<ContentType>>,
        ) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "User-Agent: {0}, Content-Type: {1}\n",
                        user_agent.0,
                        content_type.unwrap_or(TypedHeader(ContentType::text())).0,
                    ),
                )
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_header_hello2_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_header_hello2_into_response_make_value() -> String {
                let user_agent: TypedHeader<UserAgent> = ::core::panicking::panic(
                    "explicit panic",
                );
                let content_type: Option<TypedHeader<ContentType>> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "User-Agent: {0}, Content-Type: {1}\n",
                                user_agent.0,
                                content_type.unwrap_or(TypedHeader(ContentType::text())).0,
                            ),
                        )
                    })
                }
            }
            let value = __axum_macros_check_header_hello2_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello2_0_from_request_check()
        where
            TypedHeader<UserAgent>: ::axum::extract::FromRequestParts<()> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello2_0_from_request_call_check() {
            __axum_macros_check_header_hello2_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello2_1_from_request_check<M>()
        where
            Option<TypedHeader<ContentType>>: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello2_1_from_request_call_check() {
            __axum_macros_check_header_hello2_1_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_header_hello2_future() {
            async fn header_hello2(
                user_agent: TypedHeader<UserAgent>,
                content_type: Option<TypedHeader<ContentType>>,
            ) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "User-Agent: {0}, Content-Type: {1}\n",
                            user_agent.0,
                            content_type.unwrap_or(TypedHeader(ContentType::text())).0,
                        ),
                    )
                })
            }
            let future = header_hello2(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct JsonTest {
            #[schema(example = "Hello Json!")]
            message: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for JsonTest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "JsonTest",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "message",
                        &self.message,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for JsonTest {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "message",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                )
                                .example(
                                    Some(::serde_json::to_value(&"Hello Json!").unwrap()),
                                ),
                        )
                        .required("message");
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for JsonTest {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("JsonTest")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_response_json;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_response_json {
            #[inline]
            fn clone(&self) -> __path_response_json {
                __path_response_json
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_response_json {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_response_json {
            fn path() -> String {
                String::from("/json_response")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("json")
                                    .content(
                                        "application/json",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!("{0}", <JsonTest as utoipa::ToSchema>::name()),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("response_json"))
                    .description(Some("Json Response Test"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_response_json {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", <JsonTest as utoipa::ToSchema>::name()),
                                )
                            }),
                        ),
                        <JsonTest as utoipa::PartialSchema>::schema(),
                    ));
                <JsonTest as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn response_json() -> Json<JsonTest> {
            Json({
                JsonTest {
                    message: "Hello Json!".to_string(),
                }
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_response_json_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_response_json_into_response_make_value() -> Json<
                JsonTest,
            > {
                {
                    Json({
                        JsonTest {
                            message: "Hello Json!".to_string(),
                        }
                    })
                }
            }
            let value = __axum_macros_check_response_json_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_json_future() {
            async fn response_json() -> Json<JsonTest> {
                Json({
                    JsonTest {
                        message: "Hello Json!".to_string(),
                    }
                })
            }
            let future = response_json();
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_response_status_code;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_response_status_code {
            #[inline]
            fn clone(&self) -> __path_response_status_code {
                __path_response_status_code
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_response_status_code {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_response_status_code {
            fn path() -> String {
                String::from("/status_code")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "201",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("StatusCode is Created")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello StatusCode").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("response_status_code"))
                    .description(Some("Status Code Test"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_response_status_code {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn response_status_code() -> (StatusCode, String) {
            (StatusCode::CREATED, "Hello StatusCode!\n".to_string())
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_status_code_into_response_check()
        where
            String: ::axum::response::IntoResponse,
        {}
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_status_code_into_response_call_check() {
            __axum_macros_check_response_status_code_into_response_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_status_code_future() {
            async fn response_status_code() -> (StatusCode, String) {
                (StatusCode::CREATED, "Hello StatusCode!\n".to_string())
            }
            let future = response_status_code();
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_response_base_rest_api;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_response_base_rest_api {
            #[inline]
            fn clone(&self) -> __path_response_base_rest_api {
                __path_response_base_rest_api
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_response_base_rest_api {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_response_base_rest_api {
            fn path() -> String {
                String::from("/rest_api")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "201",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("ContentType is text ,StatusCode is Created")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"Hello StatusCode").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("response_base_rest_api"))
                    .description(Some("Rest API Test"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_response_base_rest_api {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn response_base_rest_api() -> (
            TypedHeader<ContentType>,
            (StatusCode, String),
        ) {
            (
                TypedHeader(ContentType::text()),
                (StatusCode::CREATED, "Hello Rest!!\n".to_string()),
            )
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_base_rest_api_into_response_parts_0_check()
        where
            TypedHeader<ContentType>: ::axum::response::IntoResponseParts,
        {}
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_base_rest_api_into_response_parts_0_call_check() {
            __axum_macros_check_response_base_rest_api_into_response_parts_0_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_base_rest_api_into_response_check()
        where
            (StatusCode, String): ::axum::response::IntoResponse,
        {}
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_base_rest_api_into_response_call_check() {
            __axum_macros_check_response_base_rest_api_into_response_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_response_base_rest_api_future() {
            async fn response_base_rest_api() -> (
                TypedHeader<ContentType>,
                (StatusCode, String),
            ) {
                (
                    TypedHeader(ContentType::text()),
                    (StatusCode::CREATED, "Hello Rest!!\n".to_string()),
                )
            }
            let future = response_base_rest_api();
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_state_base_counter;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_state_base_counter {
            #[inline]
            fn clone(&self) -> __path_state_base_counter {
                __path_state_base_counter
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_state_base_counter {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_state_base_counter {
            fn path() -> String {
                String::from("/state_count")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("Counter")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(
                                                    ::serde_json::to_value(&"Hello 1Times Again!\n").unwrap(),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("state_base_counter"))
                    .description(Some("State Counter"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_state_base_counter {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn state_base_counter(State(data): State<Arc<Mutex<Vec<i32>>>>) -> String {
            let mut data = data.lock().await;
            data[0] += 1;
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("Hello {0}Times Again!\n", data[0]))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_state_base_counter_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_state_base_counter_into_response_make_value() -> String {
                let State(data): State<Arc<Mutex<Vec<i32>>>> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    let mut data = data.lock().await;
                    data[0] += 1;
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Hello {0}Times Again!\n", data[0]),
                        )
                    })
                }
            }
            let value = __axum_macros_check_state_base_counter_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_base_counter_0_from_request_check<M>()
        where
            State<
                Arc<Mutex<Vec<i32>>>,
            >: ::axum::extract::FromRequest<Arc<Mutex<Vec<i32>>>, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_base_counter_0_from_request_call_check() {
            __axum_macros_check_state_base_counter_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_state_base_counter_future() {
            async fn state_base_counter(
                State(data): State<Arc<Mutex<Vec<i32>>>>,
            ) -> String {
                let mut data = data.lock().await;
                data[0] += 1;
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("Hello {0}Times Again!\n", data[0]),
                    )
                })
            }
            let future = state_base_counter(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_state_appdata_name;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_state_appdata_name {
            #[inline]
            fn clone(&self) -> __path_state_appdata_name {
                __path_state_appdata_name
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_state_appdata_name {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_state_appdata_name {
            fn path() -> String {
                String::from("/state_app_name")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("AppState")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(::serde_json::to_value(&"auth_token\n").unwrap()),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("state_appdata_name"))
                    .description(Some("State App Data (not Saved)"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_state_appdata_name {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn state_appdata_name(State(data): State<HelloAppState>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("{0}\n", data.auth_token))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_state_appdata_name_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_state_appdata_name_into_response_make_value() -> String {
                let State(data): State<HelloAppState> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("{0}\n", data.auth_token))
                    })
                }
            }
            let value = __axum_macros_check_state_appdata_name_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_name_0_from_request_check<M>()
        where
            State<HelloAppState>: ::axum::extract::FromRequest<HelloAppState, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_name_0_from_request_call_check() {
            __axum_macros_check_state_appdata_name_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_name_future() {
            async fn state_appdata_name(State(data): State<HelloAppState>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("{0}\n", data.auth_token))
                })
            }
            let future = state_appdata_name(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_state_appdata_users;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_state_appdata_users {
            #[inline]
            fn clone(&self) -> __path_state_appdata_users {
                __path_state_appdata_users
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_state_appdata_users {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_state_appdata_users {
            fn path() -> String {
                String::from("/state_app_users")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("AppState")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(Some(::serde_json::to_value(&"3\n").unwrap()))
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("state_appdata_users"))
                    .description(Some("State App Data (not Saved)"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_state_appdata_users {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn state_appdata_users(State(data): State<HelloAppState>) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_state_appdata_users_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_state_appdata_users_into_response_make_value() -> String {
                let State(data): State<HelloAppState> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
                    })
                }
            }
            let value = __axum_macros_check_state_appdata_users_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_users_0_from_request_check<M>()
        where
            State<HelloAppState>: ::axum::extract::FromRequest<HelloAppState, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_users_0_from_request_call_check() {
            __axum_macros_check_state_appdata_users_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_state_appdata_users_future() {
            async fn state_appdata_users(State(data): State<HelloAppState>) -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
                })
            }
            let future = state_appdata_users(::core::panicking::panic("explicit panic"));
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_extension_appdata_users;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_extension_appdata_users {
            #[inline]
            fn clone(&self) -> __path_extension_appdata_users {
                __path_extension_appdata_users
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_extension_appdata_users {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_extension_appdata_users {
            fn path() -> String {
                String::from("/extention_users")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("AppState")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(Some(::serde_json::to_value(&"4\n").unwrap()))
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("extension_appdata_users"))
                    .description(Some("Extention App Data (not Saved)"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_extension_appdata_users {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn extension_appdata_users(
            Extension(mut data): Extension<HelloAppState>,
        ) -> String {
            data.current_users += 1;
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
            })
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_extension_appdata_users_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_extension_appdata_users_into_response_make_value() -> String {
                let Extension(mut data): Extension<HelloAppState> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    data.current_users += 1;
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
                    })
                }
            }
            let value = __axum_macros_check_extension_appdata_users_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_extension_appdata_users_0_from_request_check<M>()
        where
            Extension<HelloAppState>: ::axum::extract::FromRequest<(), M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_extension_appdata_users_0_from_request_call_check() {
            __axum_macros_check_extension_appdata_users_0_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_extension_appdata_users_future() {
            async fn extension_appdata_users(
                Extension(mut data): Extension<HelloAppState>,
            ) -> String {
                data.current_users += 1;
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("{0}\n", data.current_users))
                })
            }
            let future = extension_appdata_users(
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct Data {
            #[schema(example = "chihuahua")]
            breed: String,
            #[schema(example = 3)]
            num_pics: Option<i32>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Data {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "breed" => _serde::__private228::Ok(__Field::__field0),
                                "num_pics" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"breed" => _serde::__private228::Ok(__Field::__field0),
                                b"num_pics" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<Data>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Data;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct Data",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Data with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Data with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(Data {
                                breed: __field0,
                                num_pics: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<
                                Option<i32>,
                            > = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("breed"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "num_pics",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("breed")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("num_pics")?
                                }
                            };
                            _serde::__private228::Ok(Data {
                                breed: __field0,
                                num_pics: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["breed", "num_pics"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Data",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<Data>,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for Data {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "breed",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                )
                                .example(
                                    Some(::serde_json::to_value(&"chihuahua").unwrap()),
                                ),
                        )
                        .required("breed");
                    object = object
                        .property(
                            "num_pics",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type({
                                    use std::iter::FromIterator;
                                    utoipa::openapi::schema::SchemaType::from_iter([
                                        utoipa::openapi::schema::Type::Integer,
                                        utoipa::openapi::schema::Type::Null,
                                    ])
                                })
                                .format(
                                    Some(
                                        utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                            utoipa::openapi::schema::KnownFormat::Int32,
                                        ),
                                    ),
                                )
                                .example(Some(::serde_json::to_value(&3).unwrap())),
                        );
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for Data {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Data")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_proxy;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_proxy {
            #[inline]
            fn clone(&self) -> __path_hello_proxy {
                __path_hello_proxy
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_proxy {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_hello_proxy {
            fn path() -> String {
                String::from("/proxy")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::APPLICATION_JSON.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::RefBuilder::new()
                                                    .ref_location_from_schema_name(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0}", <Data as utoipa::ToSchema>::name()),
                                                            )
                                                        }),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("Get breed and (optional)num_pics"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("ProxyData")
                                    .build(),
                            )
                            .build(),
                    )
                    .operation_id(Some("hello_proxy"))
                    .description(Some("Test Proxy and State Chache"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_proxy {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", <Data as utoipa::ToSchema>::name()),
                                )
                            }),
                        ),
                        <Data as utoipa::PartialSchema>::schema(),
                    ));
                <Data as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn hello_proxy(
            State(state): State<Arc<Mutex<HashMap<String, (Bytes, usize)>>>>,
            State(client): State<Client>,
            Json(data): Json<Data>,
        ) -> Result<(StatusCode, Bytes), AppError> {
            let need_pics;
            if let Some(body) = state.lock().await.get(&data.breed) {
                need_pics = if let Some(num_pics) = data.num_pics {
                    num_pics
                } else {
                    1
                };
                if need_pics == body.1 as i32 {
                    return Ok((StatusCode::OK, body.0.clone()));
                }
            }
            let mut url = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "https://dog.ceo/api/breed/{0}/images/random",
                        &data.breed,
                    ),
                )
            });
            if let Some(num_pics) = data.num_pics {
                url.push_str(
                    ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("/{0}", num_pics))
                        })
                        .as_str(),
                );
            }
            let res = client.get(url).send().await?;
            let code = res.status().as_u16();
            let body = res.bytes().await?;
            state
                .lock()
                .await
                .insert(data.breed, (body.clone(), data.num_pics.unwrap_or(1) as usize));
            Ok((StatusCode::from_u16(code).unwrap(), body))
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_proxy_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_proxy_into_response_make_value() -> Result<
                (StatusCode, Bytes),
                AppError,
            > {
                let State(state): State<Arc<Mutex<HashMap<String, (Bytes, usize)>>>> = ::core::panicking::panic(
                    "explicit panic",
                );
                let State(client): State<Client> = ::core::panicking::panic(
                    "explicit panic",
                );
                let Json(data): Json<Data> = ::core::panicking::panic("explicit panic");
                {
                    let need_pics;
                    if let Some(body) = state.lock().await.get(&data.breed) {
                        need_pics = if let Some(num_pics) = data.num_pics {
                            num_pics
                        } else {
                            1
                        };
                        if need_pics == body.1 as i32 {
                            return Ok((StatusCode::OK, body.0.clone()));
                        }
                    }
                    let mut url = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "https://dog.ceo/api/breed/{0}/images/random",
                                &data.breed,
                            ),
                        )
                    });
                    if let Some(num_pics) = data.num_pics {
                        url.push_str(
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("/{0}", num_pics))
                                })
                                .as_str(),
                        );
                    }
                    let res = client.get(url).send().await?;
                    let code = res.status().as_u16();
                    let body = res.bytes().await?;
                    state
                        .lock()
                        .await
                        .insert(
                            data.breed,
                            (body.clone(), data.num_pics.unwrap_or(1) as usize),
                        );
                    Ok((StatusCode::from_u16(code).unwrap(), body))
                }
            }
            let value = __axum_macros_check_hello_proxy_into_response_make_value().await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_0_from_request_check()
        where
            State<
                Arc<Mutex<HashMap<String, (Bytes, usize)>>>,
            >: ::axum::extract::FromRequestParts<HelloState> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_0_from_request_call_check() {
            __axum_macros_check_hello_proxy_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_1_from_request_check()
        where
            State<Client>: ::axum::extract::FromRequestParts<HelloState> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_1_from_request_call_check() {
            __axum_macros_check_hello_proxy_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_2_from_request_check()
        where
            Json<Data>: ::axum::extract::FromRequest<HelloState> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_2_from_request_call_check() {
            __axum_macros_check_hello_proxy_2_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_proxy_future() {
            async fn hello_proxy(
                State(state): State<Arc<Mutex<HashMap<String, (Bytes, usize)>>>>,
                State(client): State<Client>,
                Json(data): Json<Data>,
            ) -> Result<(StatusCode, Bytes), AppError> {
                let need_pics;
                if let Some(body) = state.lock().await.get(&data.breed) {
                    need_pics = if let Some(num_pics) = data.num_pics {
                        num_pics
                    } else {
                        1
                    };
                    if need_pics == body.1 as i32 {
                        return Ok((StatusCode::OK, body.0.clone()));
                    }
                }
                let mut url = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "https://dog.ceo/api/breed/{0}/images/random",
                            &data.breed,
                        ),
                    )
                });
                if let Some(num_pics) = data.num_pics {
                    url.push_str(
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(format_args!("/{0}", num_pics))
                            })
                            .as_str(),
                    );
                }
                let res = client.get(url).send().await?;
                let code = res.status().as_u16();
                let body = res.bytes().await?;
                state
                    .lock()
                    .await
                    .insert(
                        data.breed,
                        (body.clone(), data.num_pics.unwrap_or(1) as usize),
                    );
                Ok((StatusCode::from_u16(code).unwrap(), body))
            }
            let future = hello_proxy(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct HelloUserCondition {
            id: Option<i32>,
            like_user: Option<String>,
            like_pass: Option<String>,
            gt_id: Option<i32>,
            lt_id: Option<i32>,
            limit: Option<u64>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserCondition {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                2u64 => _serde::__private228::Ok(__Field::__field2),
                                3u64 => _serde::__private228::Ok(__Field::__field3),
                                4u64 => _serde::__private228::Ok(__Field::__field4),
                                5u64 => _serde::__private228::Ok(__Field::__field5),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private228::Ok(__Field::__field0),
                                "like_user" => _serde::__private228::Ok(__Field::__field1),
                                "like_pass" => _serde::__private228::Ok(__Field::__field2),
                                "gt_id" => _serde::__private228::Ok(__Field::__field3),
                                "lt_id" => _serde::__private228::Ok(__Field::__field4),
                                "limit" => _serde::__private228::Ok(__Field::__field5),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private228::Ok(__Field::__field0),
                                b"like_user" => _serde::__private228::Ok(__Field::__field1),
                                b"like_pass" => _serde::__private228::Ok(__Field::__field2),
                                b"gt_id" => _serde::__private228::Ok(__Field::__field3),
                                b"lt_id" => _serde::__private228::Ok(__Field::__field4),
                                b"limit" => _serde::__private228::Ok(__Field::__field5),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<HelloUserCondition>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserCondition;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct HelloUserCondition",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<u64>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct HelloUserCondition with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(HelloUserCondition {
                                id: __field0,
                                like_user: __field1,
                                like_pass: __field2,
                                gt_id: __field3,
                                lt_id: __field4,
                                limit: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<
                                Option<i32>,
                            > = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<
                                Option<String>,
                            > = _serde::__private228::None;
                            let mut __field2: _serde::__private228::Option<
                                Option<String>,
                            > = _serde::__private228::None;
                            let mut __field3: _serde::__private228::Option<
                                Option<i32>,
                            > = _serde::__private228::None;
                            let mut __field4: _serde::__private228::Option<
                                Option<i32>,
                            > = _serde::__private228::None;
                            let mut __field5: _serde::__private228::Option<
                                Option<u64>,
                            > = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "like_user",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private228::Option::is_some(&__field2) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "like_pass",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private228::Option::is_some(&__field3) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("gt_id"),
                                            );
                                        }
                                        __field3 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private228::Option::is_some(&__field4) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("lt_id"),
                                            );
                                        }
                                        __field4 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private228::Option::is_some(&__field5) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                            );
                                        }
                                        __field5 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<u64>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("like_user")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private228::Some(__field2) => __field2,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("like_pass")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private228::Some(__field3) => __field3,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("gt_id")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private228::Some(__field4) => __field4,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("lt_id")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private228::Some(__field5) => __field5,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("limit")?
                                }
                            };
                            _serde::__private228::Ok(HelloUserCondition {
                                id: __field0,
                                like_user: __field1,
                                like_pass: __field2,
                                gt_id: __field3,
                                lt_id: __field4,
                                limit: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "like_user",
                        "like_pass",
                        "gt_id",
                        "lt_id",
                        "limit",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HelloUserCondition",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<
                                HelloUserCondition,
                            >,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::IntoParams for HelloUserCondition {
            fn into_params(
                parameter_in_provider: impl Fn(
                ) -> Option<utoipa::openapi::path::ParameterIn>,
            ) -> Vec<utoipa::openapi::path::Parameter> {
                [
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("id")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::Integer,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        })
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("like_user")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::String,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        }),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("like_pass")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::String,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        }),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("gt_id")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::Integer,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        })
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("lt_id")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::Integer,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        })
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("limit")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::False)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type({
                                            use std::iter::FromIterator;
                                            utoipa::openapi::schema::SchemaType::from_iter([
                                                utoipa::openapi::schema::Type::Integer,
                                                utoipa::openapi::schema::Type::Null,
                                            ])
                                        })
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int64,
                                                ),
                                            ),
                                        )
                                        .minimum(Some(0f64)),
                                ),
                            )
                            .build(),
                    ),
                ]
                    .into_iter()
                    .filter(Option::is_some)
                    .flatten()
                    .collect()
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_user_select;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_user_select {
            #[inline]
            fn clone(&self) -> __path_hello_user_select {
                __path_hello_user_select
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_user_select {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_hello_user_select {
            fn path() -> String {
                String::from("/db/select")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("")
                                    .content(
                                        "application/json",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::schema::RefBuilder::new()
                                                        .ref_location_from_schema_name(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                                                )
                                                            }),
                                                        ),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .response(
                                "500",
                                utoipa::openapi::ResponseBuilder::new()
                                    .description("")
                                    .content(
                                        "text/plain",
                                        utoipa::openapi::content::ContentBuilder::new()
                                            .schema(
                                                Some(
                                                    utoipa::openapi::ObjectBuilder::new()
                                                        .schema_type(
                                                            utoipa::openapi::schema::SchemaType::new(
                                                                utoipa::openapi::schema::Type::String,
                                                            ),
                                                        ),
                                                ),
                                            )
                                            .example(
                                                Some(
                                                    ::serde_json::to_value(&"Somthing is wrong about Database")
                                                        .unwrap(),
                                                ),
                                            )
                                            .into(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default(),
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_key", []),
                        ]),
                    )
                    .operation_id(Some("hello_user_select"))
                    .parameters(
                        Some(
                            <HelloUserCondition as utoipa::IntoParams>::into_params(|| Some(
                                utoipa::openapi::path::ParameterIn::Query,
                            )),
                        ),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_user_select {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                )
                            }),
                        ),
                        <UserDTO as utoipa::PartialSchema>::schema(),
                    ));
                <UserDTO as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn hello_user_select(
            Query(opt): Query<HelloUserCondition>,
            State(pool): State<DatabaseConnection>,
            headers: HeaderMap,
        ) -> Result<Json<Vec<UserDTO>>, AppError> {
            match check_api_key(false, headers) {
                Ok(_) => {}
                Err(err) => return Err(err),
            }
            if let Some(id) = opt.id {
                return Ok(
                    Json(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                hello_select_one(&pool, id).await?.into(),
                            ]),
                        ),
                    ),
                );
            }
            let mut condition = Condition::all();
            if let Some(like_user) = opt.like_user {
                condition = condition
                    .add(
                        users::Column::Username
                            .like(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("%{0}%", like_user))
                                }),
                            ),
                    );
            }
            if let Some(like_pass) = opt.like_pass {
                condition = condition
                    .add(
                        users::Column::Password
                            .like(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("%{0}%", like_pass))
                                }),
                            ),
                    );
            }
            if let Some(gt_id) = opt.gt_id {
                if let Some(lt_id) = opt.lt_id {
                    let temp = Condition::all()
                        .add(users::Column::Id.gt(gt_id))
                        .add(users::Column::Id.lt(lt_id));
                    condition = condition.add(temp);
                } else {
                    condition = condition.add(users::Column::Id.gt(gt_id));
                }
            } else if let Some(lt_id) = opt.lt_id {
                condition = condition.add(users::Column::Id.lt(lt_id));
            }
            let result = hello_select_all(&pool, condition, opt.limit).await?;
            Ok(Json(result.into_iter().map(|v| v.into()).collect()))
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_user_select_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_user_select_into_response_make_value() -> Result<
                Json<Vec<UserDTO>>,
                AppError,
            > {
                let Query(opt): Query<HelloUserCondition> = ::core::panicking::panic(
                    "explicit panic",
                );
                let State(pool): State<DatabaseConnection> = ::core::panicking::panic(
                    "explicit panic",
                );
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                {
                    match check_api_key(false, headers) {
                        Ok(_) => {}
                        Err(err) => return Err(err),
                    }
                    if let Some(id) = opt.id {
                        return Ok(
                            Json(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        hello_select_one(&pool, id).await?.into(),
                                    ]),
                                ),
                            ),
                        );
                    }
                    let mut condition = Condition::all();
                    if let Some(like_user) = opt.like_user {
                        condition = condition
                            .add(
                                users::Column::Username
                                    .like(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("%{0}%", like_user))
                                        }),
                                    ),
                            );
                    }
                    if let Some(like_pass) = opt.like_pass {
                        condition = condition
                            .add(
                                users::Column::Password
                                    .like(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("%{0}%", like_pass))
                                        }),
                                    ),
                            );
                    }
                    if let Some(gt_id) = opt.gt_id {
                        if let Some(lt_id) = opt.lt_id {
                            let temp = Condition::all()
                                .add(users::Column::Id.gt(gt_id))
                                .add(users::Column::Id.lt(lt_id));
                            condition = condition.add(temp);
                        } else {
                            condition = condition.add(users::Column::Id.gt(gt_id));
                        }
                    } else if let Some(lt_id) = opt.lt_id {
                        condition = condition.add(users::Column::Id.lt(lt_id));
                    }
                    let result = hello_select_all(&pool, condition, opt.limit).await?;
                    Ok(Json(result.into_iter().map(|v| v.into()).collect()))
                }
            }
            let value = __axum_macros_check_hello_user_select_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_0_from_request_check()
        where
            Query<
                HelloUserCondition,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_0_from_request_call_check() {
            __axum_macros_check_hello_user_select_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_1_from_request_check()
        where
            State<
                DatabaseConnection,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_1_from_request_call_check() {
            __axum_macros_check_hello_user_select_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_2_from_request_check<M>()
        where
            HeaderMap: ::axum::extract::FromRequest<DatabaseConnection, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_2_from_request_call_check() {
            __axum_macros_check_hello_user_select_2_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_select_future() {
            async fn hello_user_select(
                Query(opt): Query<HelloUserCondition>,
                State(pool): State<DatabaseConnection>,
                headers: HeaderMap,
            ) -> Result<Json<Vec<UserDTO>>, AppError> {
                match check_api_key(false, headers) {
                    Ok(_) => {}
                    Err(err) => return Err(err),
                }
                if let Some(id) = opt.id {
                    return Ok(
                        Json(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    hello_select_one(&pool, id).await?.into(),
                                ]),
                            ),
                        ),
                    );
                }
                let mut condition = Condition::all();
                if let Some(like_user) = opt.like_user {
                    condition = condition
                        .add(
                            users::Column::Username
                                .like(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(format_args!("%{0}%", like_user))
                                    }),
                                ),
                        );
                }
                if let Some(like_pass) = opt.like_pass {
                    condition = condition
                        .add(
                            users::Column::Password
                                .like(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(format_args!("%{0}%", like_pass))
                                    }),
                                ),
                        );
                }
                if let Some(gt_id) = opt.gt_id {
                    if let Some(lt_id) = opt.lt_id {
                        let temp = Condition::all()
                            .add(users::Column::Id.gt(gt_id))
                            .add(users::Column::Id.lt(lt_id));
                        condition = condition.add(temp);
                    } else {
                        condition = condition.add(users::Column::Id.gt(gt_id));
                    }
                } else if let Some(lt_id) = opt.lt_id {
                    condition = condition.add(users::Column::Id.lt(lt_id));
                }
                let result = hello_select_all(&pool, condition, opt.limit).await?;
                Ok(Json(result.into_iter().map(|v| v.into()).collect()))
            }
            let future = hello_user_select(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        #[serde(rename_all = "snake_case")]
        enum HelloUserExec {
            One1,
            One2,
            Many,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserExec {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                2u64 => _serde::__private228::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private228::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "one1" => _serde::__private228::Ok(__Field::__field0),
                                "one2" => _serde::__private228::Ok(__Field::__field1),
                                "many" => _serde::__private228::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private228::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"one1" => _serde::__private228::Ok(__Field::__field0),
                                b"one2" => _serde::__private228::Ok(__Field::__field1),
                                b"many" => _serde::__private228::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private228::from_utf8_lossy(
                                        __value,
                                    );
                                    _serde::__private228::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<HelloUserExec>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserExec;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "enum HelloUserExec",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private228::Ok(HelloUserExec::One1)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private228::Ok(HelloUserExec::One2)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private228::Ok(HelloUserExec::Many)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["one1", "one2", "many"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "HelloUserExec",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<HelloUserExec>,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for HelloUserExec {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder()
                    .schema_type(
                        utoipa::openapi::schema::SchemaType::new(
                            utoipa::openapi::schema::Type::String,
                        ),
                    )
                    .enum_values::<[&str; 3usize], &str>(Some(["one1", "one2", "many"]))
                    .into()
            }
        }
        impl utoipa::ToSchema for HelloUserExec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("HelloUserExec")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        struct HelloUserExecCommand {
            command: HelloUserExec,
            username: String,
            password: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserExecCommand {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                2u64 => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "command" => _serde::__private228::Ok(__Field::__field0),
                                "username" => _serde::__private228::Ok(__Field::__field1),
                                "password" => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"command" => _serde::__private228::Ok(__Field::__field0),
                                b"username" => _serde::__private228::Ok(__Field::__field1),
                                b"password" => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<HelloUserExecCommand>,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserExecCommand;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct HelloUserExecCommand",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                HelloUserExec,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HelloUserExecCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HelloUserExecCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct HelloUserExecCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(HelloUserExecCommand {
                                command: __field0,
                                username: __field1,
                                password: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<
                                HelloUserExec,
                            > = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                            let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "command",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                HelloUserExec,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "username",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private228::Option::is_some(&__field2) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "password",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("command")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("username")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private228::Some(__field2) => __field2,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("password")?
                                }
                            };
                            _serde::__private228::Ok(HelloUserExecCommand {
                                command: __field0,
                                username: __field1,
                                password: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "command",
                        "username",
                        "password",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HelloUserExecCommand",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<
                                HelloUserExecCommand,
                            >,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::IntoParams for HelloUserExecCommand {
            fn into_params(
                parameter_in_provider: impl Fn(
                ) -> Option<utoipa::openapi::path::ParameterIn>,
            ) -> Vec<utoipa::openapi::path::Parameter> {
                [
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("command")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::True)
                            .schema(
                                Some(
                                    utoipa::openapi::schema::RefBuilder::new()
                                        .ref_location_from_schema_name(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0}",
                                                        <HelloUserExec as utoipa::ToSchema>::name(),
                                                    ),
                                                )
                                            }),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("username")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::True)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                    Some(
                        utoipa::openapi::path::ParameterBuilder::new()
                            .name("password")
                            .parameter_in(parameter_in_provider().unwrap_or_default())
                            .required(utoipa::openapi::Required::True)
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .build(),
                    ),
                ]
                    .into_iter()
                    .filter(Option::is_some)
                    .flatten()
                    .collect()
            }
        }
        impl utoipa::__dev::ComposeSchema for HelloUserExecCommand {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "command",
                            utoipa::openapi::schema::RefBuilder::new()
                                .ref_location_from_schema_name(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "{0}",
                                                <HelloUserExec as utoipa::ToSchema>::name(),
                                            ),
                                        )
                                    }),
                                ),
                        )
                        .required("command");
                    object = object
                        .property(
                            "username",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                ),
                        )
                        .required("username");
                    object = object
                        .property(
                            "password",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                ),
                        )
                        .required("password");
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for HelloUserExecCommand {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("HelloUserExecCommand")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .extend([
                        (
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}",
                                            <HelloUserExec as utoipa::ToSchema>::name(),
                                        ),
                                    )
                                }),
                            ),
                            <HelloUserExec as utoipa::PartialSchema>::schema(),
                        ),
                    ]);
                <HelloUserExec as utoipa::ToSchema>::schemas(schemas);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_user_insert;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_user_insert {
            #[inline]
            fn clone(&self) -> __path_hello_user_insert {
                __path_hello_user_insert
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_user_insert {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_hello_user_insert {
            fn path() -> String {
                String::from("/db/insert")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "201",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "500",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "400",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .build(),
                    )
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_key", []),
                        ]),
                    )
                    .operation_id(Some("hello_user_insert"))
                    .parameters(
                        Some(
                            <HelloUserExecCommand as utoipa::IntoParams>::into_params(|| Some(
                                utoipa::openapi::path::ParameterIn::Query,
                            )),
                        ),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_user_insert {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        async fn hello_user_insert(
            Query(command): Query<HelloUserExecCommand>,
            State(pool): State<DatabaseConnection>,
            headers: HeaderMap,
        ) -> Result<StatusCode, AppError> {
            match check_api_key(true, headers) {
                Ok(_) => {}
                Err(err) => return Err(err),
            }
            match command.command {
                HelloUserExec::One1 => {
                    hello_insert_one1(&pool, command.username, command.password).await?;
                }
                HelloUserExec::One2 => {
                    hello_insert_one2(&pool, command.username, command.password).await?;
                }
                _ => {
                    return Err(
                        AppError::new(
                            StatusCode::BAD_REQUEST,
                            "Many Insert is moved other url\nPlease use the /hello/db/insert_many",
                        ),
                    );
                }
            }
            Ok(StatusCode::CREATED)
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_user_insert_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_user_insert_into_response_make_value() -> Result<
                StatusCode,
                AppError,
            > {
                let Query(command): Query<HelloUserExecCommand> = ::core::panicking::panic(
                    "explicit panic",
                );
                let State(pool): State<DatabaseConnection> = ::core::panicking::panic(
                    "explicit panic",
                );
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                {
                    match check_api_key(true, headers) {
                        Ok(_) => {}
                        Err(err) => return Err(err),
                    }
                    match command.command {
                        HelloUserExec::One1 => {
                            hello_insert_one1(&pool, command.username, command.password)
                                .await?;
                        }
                        HelloUserExec::One2 => {
                            hello_insert_one2(&pool, command.username, command.password)
                                .await?;
                        }
                        _ => {
                            return Err(
                                AppError::new(
                                    StatusCode::BAD_REQUEST,
                                    "Many Insert is moved other url\nPlease use the /hello/db/insert_many",
                                ),
                            );
                        }
                    }
                    Ok(StatusCode::CREATED)
                }
            }
            let value = __axum_macros_check_hello_user_insert_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_0_from_request_check()
        where
            Query<
                HelloUserExecCommand,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_0_from_request_call_check() {
            __axum_macros_check_hello_user_insert_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_1_from_request_check()
        where
            State<
                DatabaseConnection,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_1_from_request_call_check() {
            __axum_macros_check_hello_user_insert_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_2_from_request_check<M>()
        where
            HeaderMap: ::axum::extract::FromRequest<DatabaseConnection, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_2_from_request_call_check() {
            __axum_macros_check_hello_user_insert_2_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_future() {
            async fn hello_user_insert(
                Query(command): Query<HelloUserExecCommand>,
                State(pool): State<DatabaseConnection>,
                headers: HeaderMap,
            ) -> Result<StatusCode, AppError> {
                match check_api_key(true, headers) {
                    Ok(_) => {}
                    Err(err) => return Err(err),
                }
                match command.command {
                    HelloUserExec::One1 => {
                        hello_insert_one1(&pool, command.username, command.password)
                            .await?;
                    }
                    HelloUserExec::One2 => {
                        hello_insert_one2(&pool, command.username, command.password)
                            .await?;
                    }
                    _ => {
                        return Err(
                            AppError::new(
                                StatusCode::BAD_REQUEST,
                                "Many Insert is moved other url\nPlease use the /hello/db/insert_many",
                            ),
                        );
                    }
                }
                Ok(StatusCode::CREATED)
            }
            let future = hello_user_insert(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct HelloUserInsertManyCommand {
            username: String,
            password: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserInsertManyCommand {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "username" => _serde::__private228::Ok(__Field::__field0),
                                "password" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"username" => _serde::__private228::Ok(__Field::__field0),
                                b"password" => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<
                            HelloUserInsertManyCommand,
                        >,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserInsertManyCommand;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct HelloUserInsertManyCommand",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HelloUserInsertManyCommand with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HelloUserInsertManyCommand with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(HelloUserInsertManyCommand {
                                username: __field0,
                                password: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "username",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "password",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("username")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("password")?
                                }
                            };
                            _serde::__private228::Ok(HelloUserInsertManyCommand {
                                username: __field0,
                                password: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["username", "password"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HelloUserInsertManyCommand",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<
                                HelloUserInsertManyCommand,
                            >,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for HelloUserInsertManyCommand {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "username",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                ),
                        )
                        .required("username");
                    object = object
                        .property(
                            "password",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type(
                                    utoipa::openapi::schema::SchemaType::new(
                                        utoipa::openapi::schema::Type::String,
                                    ),
                                ),
                        )
                        .required("password");
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for HelloUserInsertManyCommand {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("HelloUserInsertManyCommand")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_user_insert_many;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_user_insert_many {
            #[inline]
            fn clone(&self) -> __path_hello_user_insert_many {
                __path_hello_user_insert_many
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_user_insert_many {
            fn tags() -> Vec<&'t str> {
                [HELLO_TAG].into()
            }
        }
        impl utoipa::Path for __path_hello_user_insert_many {
            fn path() -> String {
                String::from("/db/insert_many")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::APPLICATION_JSON.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::ArrayBuilder::new()
                                                    .items(
                                                        utoipa::openapi::schema::RefBuilder::new()
                                                            .ref_location_from_schema_name(
                                                                ::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!(
                                                                            "{0}",
                                                                            <HelloUserInsertManyCommand as utoipa::ToSchema>::name(),
                                                                        ),
                                                                    )
                                                                }),
                                                            ),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("User List"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "201",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "500",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "400",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .build(),
                    )
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_key", []),
                        ]),
                    )
                    .operation_id(Some("hello_user_insert_many"))
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_user_insert_many {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}",
                                        <HelloUserInsertManyCommand as utoipa::ToSchema>::name(),
                                    ),
                                )
                            }),
                        ),
                        <HelloUserInsertManyCommand as utoipa::PartialSchema>::schema(),
                    ));
                <HelloUserInsertManyCommand as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn hello_user_insert_many(
            State(pool): State<DatabaseConnection>,
            headers: HeaderMap,
            Json(command): Json<Vec<HelloUserInsertManyCommand>>,
        ) -> Result<StatusCode, AppError> {
            match check_api_key(true, headers) {
                Ok(_) => {}
                Err(err) => return Err(err),
            }
            let models: Vec<(String, String)> = command
                .into_iter()
                .map(|com| (com.username, com.password))
                .collect();
            hello_insert_many(&pool, models).await?;
            Ok(StatusCode::CREATED)
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_user_insert_many_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_user_insert_many_into_response_make_value() -> Result<
                StatusCode,
                AppError,
            > {
                let State(pool): State<DatabaseConnection> = ::core::panicking::panic(
                    "explicit panic",
                );
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                let Json(command): Json<Vec<HelloUserInsertManyCommand>> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    match check_api_key(true, headers) {
                        Ok(_) => {}
                        Err(err) => return Err(err),
                    }
                    let models: Vec<(String, String)> = command
                        .into_iter()
                        .map(|com| (com.username, com.password))
                        .collect();
                    hello_insert_many(&pool, models).await?;
                    Ok(StatusCode::CREATED)
                }
            }
            let value = __axum_macros_check_hello_user_insert_many_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_0_from_request_check()
        where
            State<
                DatabaseConnection,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_0_from_request_call_check() {
            __axum_macros_check_hello_user_insert_many_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_1_from_request_check()
        where
            HeaderMap: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_1_from_request_call_check() {
            __axum_macros_check_hello_user_insert_many_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_2_from_request_check()
        where
            Json<
                Vec<HelloUserInsertManyCommand>,
            >: ::axum::extract::FromRequest<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_2_from_request_call_check() {
            __axum_macros_check_hello_user_insert_many_2_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_insert_many_future() {
            async fn hello_user_insert_many(
                State(pool): State<DatabaseConnection>,
                headers: HeaderMap,
                Json(command): Json<Vec<HelloUserInsertManyCommand>>,
            ) -> Result<StatusCode, AppError> {
                match check_api_key(true, headers) {
                    Ok(_) => {}
                    Err(err) => return Err(err),
                }
                let models: Vec<(String, String)> = command
                    .into_iter()
                    .map(|com| (com.username, com.password))
                    .collect();
                hello_insert_many(&pool, models).await?;
                Ok(StatusCode::CREATED)
            }
            let future = hello_user_insert_many(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct HelloUserUpdateCommand {
            model: Option<HelloUserDeleteCommand>,
            change_model: UserDTO,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserUpdateCommand {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "model" => _serde::__private228::Ok(__Field::__field0),
                                "change_model" => {
                                    _serde::__private228::Ok(__Field::__field1)
                                }
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"model" => _serde::__private228::Ok(__Field::__field0),
                                b"change_model" => {
                                    _serde::__private228::Ok(__Field::__field1)
                                }
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<
                            HelloUserUpdateCommand,
                        >,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserUpdateCommand;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct HelloUserUpdateCommand",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<HelloUserDeleteCommand>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HelloUserUpdateCommand with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                UserDTO,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HelloUserUpdateCommand with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(HelloUserUpdateCommand {
                                model: __field0,
                                change_model: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<
                                Option<HelloUserDeleteCommand>,
                            > = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<UserDTO> = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("model"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<HelloUserDeleteCommand>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "change_model",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<UserDTO>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("model")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("change_model")?
                                }
                            };
                            _serde::__private228::Ok(HelloUserUpdateCommand {
                                model: __field0,
                                change_model: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["model", "change_model"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HelloUserUpdateCommand",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<
                                HelloUserUpdateCommand,
                            >,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for HelloUserUpdateCommand {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "model",
                            utoipa::openapi::schema::OneOfBuilder::new()
                                .item(
                                    utoipa::openapi::schema::ObjectBuilder::new()
                                        .schema_type(utoipa::openapi::schema::Type::Null),
                                )
                                .item(
                                    utoipa::openapi::schema::RefBuilder::new()
                                        .ref_location_from_schema_name(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0}",
                                                        <HelloUserDeleteCommand as utoipa::ToSchema>::name(),
                                                    ),
                                                )
                                            }),
                                        ),
                                ),
                        );
                    object = object
                        .property(
                            "change_model",
                            utoipa::openapi::schema::RefBuilder::new()
                                .ref_location_from_schema_name(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                        )
                                    }),
                                ),
                        )
                        .required("change_model");
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for HelloUserUpdateCommand {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("HelloUserUpdateCommand")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .extend([
                        (
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}",
                                            <HelloUserDeleteCommand as utoipa::ToSchema>::name(),
                                        ),
                                    )
                                }),
                            ),
                            <HelloUserDeleteCommand as utoipa::PartialSchema>::schema(),
                        ),
                        (
                            String::from(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}", <UserDTO as utoipa::ToSchema>::name()),
                                    )
                                }),
                            ),
                            <UserDTO as utoipa::PartialSchema>::schema(),
                        ),
                    ]);
                <HelloUserDeleteCommand as utoipa::ToSchema>::schemas(schemas);
                <UserDTO as utoipa::ToSchema>::schemas(schemas);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_user_update;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_user_update {
            #[inline]
            fn clone(&self) -> __path_hello_user_update {
                __path_hello_user_update
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_user_update {
            fn tags() -> Vec<&'t str> {
                [].into()
            }
        }
        impl utoipa::Path for __path_hello_user_update {
            fn path() -> String {
                String::from("/db/update/{exec}")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::APPLICATION_JSON.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::RefBuilder::new()
                                                    .ref_location_from_schema_name(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!(
                                                                    "{0}",
                                                                    <HelloUserUpdateCommand as utoipa::ToSchema>::name(),
                                                                ),
                                                            )
                                                        }),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("find user info mation"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "500",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .build(),
                    )
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_key", []),
                        ]),
                    )
                    .operation_id(Some("hello_user_update"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("exec"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Path)
                            .description(Some("Execution type"))
                            .schema(
                                Some(
                                    utoipa::openapi::schema::RefBuilder::new()
                                        .ref_location_from_schema_name(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0}",
                                                        <HelloUserExec as utoipa::ToSchema>::name(),
                                                    ),
                                                )
                                            }),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_user_update {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}",
                                        <HelloUserUpdateCommand as utoipa::ToSchema>::name(),
                                    ),
                                )
                            }),
                        ),
                        <HelloUserUpdateCommand as utoipa::PartialSchema>::schema(),
                    ));
                <HelloUserUpdateCommand as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn hello_user_update(
            Path(exec): Path<HelloUserExec>,
            State(pool): State<DatabaseConnection>,
            headers: HeaderMap,
            Json(model): Json<HelloUserUpdateCommand>,
        ) -> Result<StatusCode, AppError> {
            match check_api_key(true, headers) {
                Ok(_) => {}
                Err(err) => return Err(err),
            }
            match exec {
                HelloUserExec::One1 => {
                    if let Some(find) = model.model {
                        if let Some(id) = find.id {
                            hello_update_one1(
                                    &pool,
                                    id,
                                    model.change_model.username,
                                    model.change_model.password,
                                )
                                .await?;
                        }
                    }
                }
                HelloUserExec::One2 => {
                    if let Some(find) = model.model {
                        if let (Some(id), Some(username), Some(password)) = (
                            find.id,
                            find.username,
                            find.password,
                        ) {
                            let find = users::Model {
                                id,
                                username,
                                password,
                            };
                            hello_update_one2(
                                    &pool,
                                    find,
                                    model.change_model.username,
                                    model.change_model.password,
                                )
                                .await?;
                        }
                    }
                }
                HelloUserExec::Many => {
                    hello_update_many(
                            &pool,
                            model.change_model.username,
                            model.change_model.password,
                        )
                        .await?;
                }
            }
            Ok(StatusCode::OK)
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_user_update_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_user_update_into_response_make_value() -> Result<
                StatusCode,
                AppError,
            > {
                let Path(exec): Path<HelloUserExec> = ::core::panicking::panic(
                    "explicit panic",
                );
                let State(pool): State<DatabaseConnection> = ::core::panicking::panic(
                    "explicit panic",
                );
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                let Json(model): Json<HelloUserUpdateCommand> = ::core::panicking::panic(
                    "explicit panic",
                );
                {
                    match check_api_key(true, headers) {
                        Ok(_) => {}
                        Err(err) => return Err(err),
                    }
                    match exec {
                        HelloUserExec::One1 => {
                            if let Some(find) = model.model {
                                if let Some(id) = find.id {
                                    hello_update_one1(
                                            &pool,
                                            id,
                                            model.change_model.username,
                                            model.change_model.password,
                                        )
                                        .await?;
                                }
                            }
                        }
                        HelloUserExec::One2 => {
                            if let Some(find) = model.model {
                                if let (Some(id), Some(username), Some(password)) = (
                                    find.id,
                                    find.username,
                                    find.password,
                                ) {
                                    let find = users::Model {
                                        id,
                                        username,
                                        password,
                                    };
                                    hello_update_one2(
                                            &pool,
                                            find,
                                            model.change_model.username,
                                            model.change_model.password,
                                        )
                                        .await?;
                                }
                            }
                        }
                        HelloUserExec::Many => {
                            hello_update_many(
                                    &pool,
                                    model.change_model.username,
                                    model.change_model.password,
                                )
                                .await?;
                        }
                    }
                    Ok(StatusCode::OK)
                }
            }
            let value = __axum_macros_check_hello_user_update_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_0_from_request_check()
        where
            Path<
                HelloUserExec,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_0_from_request_call_check() {
            __axum_macros_check_hello_user_update_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_1_from_request_check()
        where
            State<
                DatabaseConnection,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_1_from_request_call_check() {
            __axum_macros_check_hello_user_update_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_2_from_request_check()
        where
            HeaderMap: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_2_from_request_call_check() {
            __axum_macros_check_hello_user_update_2_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_3_from_request_check()
        where
            Json<
                HelloUserUpdateCommand,
            >: ::axum::extract::FromRequest<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_3_from_request_call_check() {
            __axum_macros_check_hello_user_update_3_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_update_future() {
            async fn hello_user_update(
                Path(exec): Path<HelloUserExec>,
                State(pool): State<DatabaseConnection>,
                headers: HeaderMap,
                Json(model): Json<HelloUserUpdateCommand>,
            ) -> Result<StatusCode, AppError> {
                match check_api_key(true, headers) {
                    Ok(_) => {}
                    Err(err) => return Err(err),
                }
                match exec {
                    HelloUserExec::One1 => {
                        if let Some(find) = model.model {
                            if let Some(id) = find.id {
                                hello_update_one1(
                                        &pool,
                                        id,
                                        model.change_model.username,
                                        model.change_model.password,
                                    )
                                    .await?;
                            }
                        }
                    }
                    HelloUserExec::One2 => {
                        if let Some(find) = model.model {
                            if let (Some(id), Some(username), Some(password)) = (
                                find.id,
                                find.username,
                                find.password,
                            ) {
                                let find = users::Model {
                                    id,
                                    username,
                                    password,
                                };
                                hello_update_one2(
                                        &pool,
                                        find,
                                        model.change_model.username,
                                        model.change_model.password,
                                    )
                                    .await?;
                            }
                        }
                    }
                    HelloUserExec::Many => {
                        hello_update_many(
                                &pool,
                                model.change_model.username,
                                model.change_model.password,
                            )
                            .await?;
                    }
                }
                Ok(StatusCode::OK)
            }
            let future = hello_user_update(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        struct HelloUserDeleteCommand {
            id: Option<i32>,
            username: Option<String>,
            password: Option<String>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HelloUserDeleteCommand {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private228::Ok(__Field::__field0),
                                1u64 => _serde::__private228::Ok(__Field::__field1),
                                2u64 => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private228::Ok(__Field::__field0),
                                "username" => _serde::__private228::Ok(__Field::__field1),
                                "password" => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private228::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private228::Ok(__Field::__field0),
                                b"username" => _serde::__private228::Ok(__Field::__field1),
                                b"password" => _serde::__private228::Ok(__Field::__field2),
                                _ => _serde::__private228::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private228::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private228::PhantomData<
                            HelloUserDeleteCommand,
                        >,
                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HelloUserDeleteCommand;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private228::Formatter,
                        ) -> _serde::__private228::fmt::Result {
                            _serde::__private228::Formatter::write_str(
                                __formatter,
                                "struct HelloUserDeleteCommand",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HelloUserDeleteCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct HelloUserDeleteCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private228::Some(__value) => __value,
                                _serde::__private228::None => {
                                    return _serde::__private228::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct HelloUserDeleteCommand with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private228::Ok(HelloUserDeleteCommand {
                                id: __field0,
                                username: __field1,
                                password: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private228::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private228::Option<
                                Option<i32>,
                            > = _serde::__private228::None;
                            let mut __field1: _serde::__private228::Option<
                                Option<String>,
                            > = _serde::__private228::None;
                            let mut __field2: _serde::__private228::Option<
                                Option<String>,
                            > = _serde::__private228::None;
                            while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private228::Option::is_some(&__field0) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private228::Option::is_some(&__field1) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "username",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private228::Option::is_some(&__field2) {
                                            return _serde::__private228::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "password",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private228::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private228::Some(__field0) => __field0,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private228::Some(__field1) => __field1,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("username")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private228::Some(__field2) => __field2,
                                _serde::__private228::None => {
                                    _serde::__private228::de::missing_field("password")?
                                }
                            };
                            _serde::__private228::Ok(HelloUserDeleteCommand {
                                id: __field0,
                                username: __field1,
                                password: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "username",
                        "password",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HelloUserDeleteCommand",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private228::PhantomData::<
                                HelloUserDeleteCommand,
                            >,
                            lifetime: _serde::__private228::PhantomData,
                        },
                    )
                }
            }
        };
        impl utoipa::__dev::ComposeSchema for HelloUserDeleteCommand {
            fn compose(
                mut generics: Vec<
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>,
                >,
            ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                    let mut object = utoipa::openapi::ObjectBuilder::new();
                    object = object
                        .property(
                            "id",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type({
                                    use std::iter::FromIterator;
                                    utoipa::openapi::schema::SchemaType::from_iter([
                                        utoipa::openapi::schema::Type::Integer,
                                        utoipa::openapi::schema::Type::Null,
                                    ])
                                })
                                .format(
                                    Some(
                                        utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                            utoipa::openapi::schema::KnownFormat::Int32,
                                        ),
                                    ),
                                ),
                        );
                    object = object
                        .property(
                            "username",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type({
                                    use std::iter::FromIterator;
                                    utoipa::openapi::schema::SchemaType::from_iter([
                                        utoipa::openapi::schema::Type::String,
                                        utoipa::openapi::schema::Type::Null,
                                    ])
                                }),
                        );
                    object = object
                        .property(
                            "password",
                            utoipa::openapi::ObjectBuilder::new()
                                .schema_type({
                                    use std::iter::FromIterator;
                                    utoipa::openapi::schema::SchemaType::from_iter([
                                        utoipa::openapi::schema::Type::String,
                                        utoipa::openapi::schema::Type::Null,
                                    ])
                                }),
                        );
                    object
                }
                    .into()
            }
        }
        impl utoipa::ToSchema for HelloUserDeleteCommand {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("HelloUserDeleteCommand")
            }
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas.extend([]);
            }
        }
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_hello_user_delete;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_hello_user_delete {
            #[inline]
            fn clone(&self) -> __path_hello_user_delete {
                __path_hello_user_delete
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_hello_user_delete {
            fn tags() -> Vec<&'t str> {
                [].into()
            }
        }
        impl utoipa::Path for __path_hello_user_delete {
            fn path() -> String {
                String::from("/db/delete/{exec}")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Post].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .request_body(
                        Some(
                            utoipa::openapi::request_body::RequestBodyBuilder::new()
                                .content(
                                    mime::APPLICATION_JSON.as_ref(),
                                    utoipa::openapi::content::ContentBuilder::new()
                                        .schema(
                                            Some(
                                                utoipa::openapi::schema::RefBuilder::new()
                                                    .ref_location_from_schema_name(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!(
                                                                    "{0}",
                                                                    <HelloUserDeleteCommand as utoipa::ToSchema>::name(),
                                                                ),
                                                            )
                                                        }),
                                                    ),
                                            ),
                                        )
                                        .into(),
                                )
                                .required(Some(utoipa::openapi::Required::True))
                                .description(Some("find user info mation"))
                                .build(),
                        ),
                    )
                    .responses(
                        utoipa::openapi::ResponsesBuilder::new()
                            .response(
                                "200",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .response(
                                "500",
                                utoipa::openapi::ResponseBuilder::new().description(""),
                            )
                            .build(),
                    )
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_key", []),
                        ]),
                    )
                    .operation_id(Some("hello_user_delete"))
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("exec"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Path)
                            .description(Some("Execution type"))
                            .schema(
                                Some(
                                    utoipa::openapi::schema::RefBuilder::new()
                                        .ref_location_from_schema_name(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0}",
                                                        <HelloUserExec as utoipa::ToSchema>::name(),
                                                    ),
                                                )
                                            }),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_hello_user_delete {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {
                schemas
                    .push((
                        String::from(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}",
                                        <HelloUserDeleteCommand as utoipa::ToSchema>::name(),
                                    ),
                                )
                            }),
                        ),
                        <HelloUserDeleteCommand as utoipa::PartialSchema>::schema(),
                    ));
                <HelloUserDeleteCommand as utoipa::ToSchema>::schemas(schemas);
            }
        }
        async fn hello_user_delete(
            Path(command): Path<HelloUserExec>,
            Query(model): Query<HelloUserDeleteCommand>,
            State(pool): State<DatabaseConnection>,
            headers: HeaderMap,
        ) -> Result<StatusCode, AppError> {
            match check_api_key(true, headers) {
                Ok(_) => {}
                Err(err) => return Err(err),
            }
            match command {
                HelloUserExec::One1 => {
                    if let Some(id) = model.id {
                        hello_delete_by_id(&pool, id).await?;
                    } else {
                        return Err(
                            AppError::new(
                                StatusCode::BAD_REQUEST,
                                "Need input the user info",
                            ),
                        );
                    }
                }
                HelloUserExec::One2 => {
                    if let (Some(username), Some(password)) = (
                        model.username,
                        model.password,
                    ) {
                        hello_delete_by_model(
                                &pool,
                                users::Model {
                                    id: -1,
                                    username,
                                    password,
                                },
                            )
                            .await?;
                    } else {
                        return Err(
                            AppError::new(
                                StatusCode::BAD_REQUEST,
                                "Need input the user info",
                            ),
                        );
                    }
                }
                HelloUserExec::Many => {
                    hello_delete_many(&pool).await?;
                }
            }
            Ok(StatusCode::OK)
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        async fn __axum_macros_check_hello_user_delete_into_response() {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn __axum_macros_check_hello_user_delete_into_response_make_value() -> Result<
                StatusCode,
                AppError,
            > {
                let Path(command): Path<HelloUserExec> = ::core::panicking::panic(
                    "explicit panic",
                );
                let Query(model): Query<HelloUserDeleteCommand> = ::core::panicking::panic(
                    "explicit panic",
                );
                let State(pool): State<DatabaseConnection> = ::core::panicking::panic(
                    "explicit panic",
                );
                let headers: HeaderMap = ::core::panicking::panic("explicit panic");
                {
                    match check_api_key(true, headers) {
                        Ok(_) => {}
                        Err(err) => return Err(err),
                    }
                    match command {
                        HelloUserExec::One1 => {
                            if let Some(id) = model.id {
                                hello_delete_by_id(&pool, id).await?;
                            } else {
                                return Err(
                                    AppError::new(
                                        StatusCode::BAD_REQUEST,
                                        "Need input the user info",
                                    ),
                                );
                            }
                        }
                        HelloUserExec::One2 => {
                            if let (Some(username), Some(password)) = (
                                model.username,
                                model.password,
                            ) {
                                hello_delete_by_model(
                                        &pool,
                                        users::Model {
                                            id: -1,
                                            username,
                                            password,
                                        },
                                    )
                                    .await?;
                            } else {
                                return Err(
                                    AppError::new(
                                        StatusCode::BAD_REQUEST,
                                        "Need input the user info",
                                    ),
                                );
                            }
                        }
                        HelloUserExec::Many => {
                            hello_delete_many(&pool).await?;
                        }
                    }
                    Ok(StatusCode::OK)
                }
            }
            let value = __axum_macros_check_hello_user_delete_into_response_make_value()
                .await;
            fn check<T>(_: T)
            where
                T: ::axum::response::IntoResponse,
            {}
            check(value);
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_0_from_request_check()
        where
            Path<
                HelloUserExec,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_0_from_request_call_check() {
            __axum_macros_check_hello_user_delete_0_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_1_from_request_check()
        where
            Query<
                HelloUserDeleteCommand,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_1_from_request_call_check() {
            __axum_macros_check_hello_user_delete_1_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_2_from_request_check()
        where
            State<
                DatabaseConnection,
            >: ::axum::extract::FromRequestParts<DatabaseConnection> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_2_from_request_call_check() {
            __axum_macros_check_hello_user_delete_2_from_request_check();
        }
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_3_from_request_check<M>()
        where
            HeaderMap: ::axum::extract::FromRequest<DatabaseConnection, M> + Send,
        {}
        #[allow(warnings)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_3_from_request_call_check() {
            __axum_macros_check_hello_user_delete_3_from_request_check();
        }
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn __axum_macros_check_hello_user_delete_future() {
            async fn hello_user_delete(
                Path(command): Path<HelloUserExec>,
                Query(model): Query<HelloUserDeleteCommand>,
                State(pool): State<DatabaseConnection>,
                headers: HeaderMap,
            ) -> Result<StatusCode, AppError> {
                match check_api_key(true, headers) {
                    Ok(_) => {}
                    Err(err) => return Err(err),
                }
                match command {
                    HelloUserExec::One1 => {
                        if let Some(id) = model.id {
                            hello_delete_by_id(&pool, id).await?;
                        } else {
                            return Err(
                                AppError::new(
                                    StatusCode::BAD_REQUEST,
                                    "Need input the user info",
                                ),
                            );
                        }
                    }
                    HelloUserExec::One2 => {
                        if let (Some(username), Some(password)) = (
                            model.username,
                            model.password,
                        ) {
                            hello_delete_by_model(
                                    &pool,
                                    users::Model {
                                        id: -1,
                                        username,
                                        password,
                                    },
                                )
                                .await?;
                        } else {
                            return Err(
                                AppError::new(
                                    StatusCode::BAD_REQUEST,
                                    "Need input the user info",
                                ),
                            );
                        }
                    }
                    HelloUserExec::Many => {
                        hello_delete_many(&pool).await?;
                    }
                }
                Ok(StatusCode::OK)
            }
            let future = hello_user_delete(
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
                ::core::panicking::panic("explicit panic"),
            );
            fn check<T>(_: T)
            where
                T: ::std::future::Future + Send,
            {}
            check(future);
        }
        fn check_api_key(
            require_api_key: bool,
            headers: HeaderMap,
        ) -> Result<(), AppError> {
            match headers.get("hello_apikey") {
                Some(header) if header != "utoipa-rocks" => {
                    Err(AppError::new(StatusCode::UNAUTHORIZED, "incorrect api key"))
                }
                None if require_api_key => {
                    Err(AppError::new(StatusCode::UNAUTHORIZED, "missing api key"))
                }
                _ => Ok(()),
            }
        }
        pub fn hello_router(aex: AppExtension) -> Router {
            let db_router = OpenApiRouter::new()
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_select::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_select::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_select::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_select::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_select::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), hello_user_select)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), hello_user_insert)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert_many::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert_many::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert_many::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert_many::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_insert_many::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), hello_user_insert_many)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_update::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_update::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_update::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_update::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_update::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), hello_user_update)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_delete::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_delete::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_delete::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_delete::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_user_delete::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), hello_user_delete)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                });
            let hello_router = OpenApiRouter::new()
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_hashmap::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_hashmap::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_hashmap::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_hashmap::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_hashmap::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), param_query_with_hashmap)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_path_query::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_path_query::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_path_query::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_path_query::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_path_query::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), path_query)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_struct::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_struct::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_struct::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_struct::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_param_query_with_struct::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), param_query_with_struct)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_text::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_text::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_text::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_text::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_text::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), body_query_text)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_bytes::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_bytes::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_bytes::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_bytes::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_bytes::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), body_query_bytes)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_form::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_form::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_form::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_form::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_form::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), body_query_form)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_json::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_json::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_json::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_json::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_json::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), body_query_json)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_file_upload::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_file_upload::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_file_upload::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_file_upload::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_body_query_file_upload::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), body_query_file_upload)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello1::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello1::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello1::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello1::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello1::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), header_hello1)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello2::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello2::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello2::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello2::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_header_hello2::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), header_hello2)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_json::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_json::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_json::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_json::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_json::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), response_json)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_status_code::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_status_code::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_status_code::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_status_code::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_status_code::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), response_status_code)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_base_rest_api::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_base_rest_api::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_base_rest_api::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_base_rest_api::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_response_base_rest_api::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), response_base_rest_api)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_base_counter::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_base_counter::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_base_counter::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_base_counter::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_base_counter::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), state_base_counter)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_name::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_name::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_name::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_name::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_name::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), state_appdata_name)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_users::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_users::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_users::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_users::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_state_appdata_users::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), state_appdata_users)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_extension_appdata_users::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_extension_appdata_users::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_extension_appdata_users::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_extension_appdata_users::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_extension_appdata_users::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router
                                    .on(path_type.to_method_filter(), extension_appdata_users)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .layer(Extension(get_hello_app_state()))
                .routes({
                    use ::utoipa_axum::PathItemExt;
                    let mut paths = utoipa::openapi::path::Paths::new();
                    let mut schemas = Vec::<
                        (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                    >::new();
                    let (path, item, types) = {
                        let path = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_proxy::path()
                        };
                        let mut operation = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_proxy::operation()
                        };
                        let types = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_proxy::methods()
                        };
                        let tags = {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_proxy::tags()
                        };
                        {
                            #[allow(unused_imports)]
                            use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                            __path_hello_proxy::schemas(&mut schemas)
                        };
                        if !tags.is_empty() {
                            let operation_tags = operation
                                .tags
                                .get_or_insert(Vec::new());
                            operation_tags.extend(tags.iter().map(ToString::to_string));
                        }
                        (path, operation, types)
                    };
                    #[allow(unused_mut)]
                    let mut method_router = types
                        .iter()
                        .by_ref()
                        .fold(
                            axum::routing::MethodRouter::new(),
                            |router, path_type| {
                                router.on(path_type.to_method_filter(), hello_proxy)
                            },
                        );
                    paths.add_path_operation(&path, types, item);
                    (schemas, paths, method_router)
                })
                .nest("/db", db_router)
                .with_state(get_hello_state(aex.db.0.clone()));
            set_router(hello_router)
        }
    }
}
pub mod utils {
    pub mod errors {
        use std::fmt::Debug;
        use axum::{Json, response::IntoResponse};
        use bcrypt::BcryptError;
        use dioxus::{CapturedError, server::ServerFnError};
        use reqwest::{StatusCode, header::ToStrError};
        use sea_orm::DbErr;
        use tracing::error;
        use crate::database::DB_ERR_MESSAGE;
        pub struct AppError {
            code: StatusCode,
            message: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AppError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "AppError",
                    "code",
                    &self.code,
                    "message",
                    &&self.message,
                )
            }
        }
        impl AppError {
            pub fn new(code: StatusCode, message: impl Into<String>) -> Self {
                Self {
                    code,
                    message: message.into(),
                }
            }
            pub fn get_db_error() -> AppError {
                Self::new(StatusCode::INTERNAL_SERVER_ERROR, DB_ERR_MESSAGE)
            }
            pub fn auth_error() -> Self {
                Self::new(StatusCode::UNAUTHORIZED, "error validating token")
            }
            pub fn any_error() -> Self {
                Self::new(StatusCode::INTERNAL_SERVER_ERROR, "some thing is wrong!")
            }
            pub fn any_t_error<T: Debug>(e: T) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:37",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(37u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Any Error: {0:?}", e)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Any Error: {0:?}", e)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::new(StatusCode::INTERNAL_SERVER_ERROR, "some thing is wrong")
            }
        }
        impl From<DbErr> for AppError {
            fn from(e: DbErr) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:44",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(44u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Data base Error {0:?}", e)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Data base Error {0:?}", e)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                Self::new(StatusCode::INTERNAL_SERVER_ERROR, DB_ERR_MESSAGE)
            }
        }
        impl From<reqwest::Error> for AppError {
            fn from(value: reqwest::Error) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:50",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(50u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Requwest Error {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Requwest Error {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                Self::new(
                    StatusCode::INTERNAL_SERVER_ERROR,
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Request Error! {0:?}", value))
                    }),
                )
            }
        }
        impl From<jsonwebtoken::errors::Error> for AppError {
            fn from(value: jsonwebtoken::errors::Error) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:59",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(59u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("JWT Error {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("JWT Error {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                match value.kind() {
                    jsonwebtoken::errors::ErrorKind::InvalidToken
                    | jsonwebtoken::errors::ErrorKind::InvalidSignature
                    | jsonwebtoken::errors::ErrorKind::ExpiredSignature => {
                        AppError::auth_error()
                    }
                    _ => AppError::new(StatusCode::INTERNAL_SERVER_ERROR, "token error!"),
                }
            }
        }
        impl From<jsonwebtoken::errors::ErrorKind> for AppError {
            fn from(value: jsonwebtoken::errors::ErrorKind) -> Self {
                match value {
                    jsonwebtoken::errors::ErrorKind::InvalidToken
                    | jsonwebtoken::errors::ErrorKind::InvalidSignature
                    | jsonwebtoken::errors::ErrorKind::ExpiredSignature => {
                        AppError::auth_error()
                    }
                    _ => AppError::new(StatusCode::INTERNAL_SERVER_ERROR, "token error!"),
                }
            }
        }
        impl From<ToStrError> for AppError {
            fn from(value: ToStrError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:80",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(80u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Str Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Str Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::any_error()
            }
        }
        impl From<BcryptError> for AppError {
            fn from(value: BcryptError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:86",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(86u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("BcryptError! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("BcryptError! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::new(StatusCode::UNAUTHORIZED, "Id or Pass is wrong!")
            }
        }
        impl From<&str> for AppError {
            fn from(value: &str) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:92",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(92u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("String Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("String Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::new(StatusCode::UNAUTHORIZED, value)
            }
        }
        impl From<axum::Error> for AppError {
            fn from(value: axum::Error) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:98",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(98u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Axum Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Axum Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::any_error()
            }
        }
        impl From<ServerFnError> for AppError {
            fn from(value: ServerFnError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:104",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(104u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Dioxus Server Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Dioxus Server Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::any_error()
            }
        }
        impl From<CapturedError> for AppError {
            fn from(value: CapturedError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:110",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(110u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Dioxus Server Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Dioxus Server Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::any_error()
            }
        }
        impl From<anyhow::Error> for AppError {
            fn from(value: anyhow::Error) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:116",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(116u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Dioxus Server Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Dioxus Server Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                AppError::any_error()
            }
        }
        impl From<AppError> for ServerFnError {
            fn from(value: AppError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:123",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(123u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Dioxus Server Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Dioxus Server Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                value.into()
            }
        }
        impl From<AppError> for anyhow::Error {
            fn from(value: AppError) -> Self {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/errors.rs:129",
                                "fullstack::utils::errors",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/errors.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(129u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::errors",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Dioxus Server Error! {0:?}", value)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Dioxus Server Error! {0:?}", value)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                value.into()
            }
        }
        impl IntoResponse for AppError {
            fn into_response(self) -> axum::response::Response {
                (self.code, Json(self.message)).into_response()
            }
        }
    }
    pub mod hash {
        use bcrypt::{hash, verify};
        use crate::utils::errors::AppError;
        const COST: u32 = 12;
        pub fn hash_password(password: &str) -> Result<String, AppError> {
            Ok(hash(password, COST)?)
        }
        pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
            Ok(verify(password, hash)?)
        }
    }
    pub mod jwt {
        use axum::{
            body::Body, http::{HeaderMap, Request},
            middleware::Next, response::Response,
        };
        use chrono::{DateTime, Duration, Utc};
        use jsonwebtoken::{DecodingKey, EncodingKey, Header, Validation, decode, encode};
        use lazy_static::lazy_static;
        use reqwest::header::AUTHORIZATION;
        use sea_orm::{DatabaseConnection, EntityTrait, sea_query::OnConflict};
        use std::{env, str::FromStr};
        use tracing::debug;
        use crate::resources::{
            dto::user::{JwtClaims, RefreshClaims},
            entities::refresh_token,
        };
        use crate::utils::errors::AppError;
        pub struct CurrentUser(pub i32, pub String);
        #[automatically_derived]
        impl ::core::clone::Clone for CurrentUser {
            #[inline]
            fn clone(&self) -> CurrentUser {
                CurrentUser(
                    ::core::clone::Clone::clone(&self.0),
                    ::core::clone::Clone::clone(&self.1),
                )
            }
        }
        impl PartialEq for CurrentUser {
            fn eq(&self, other: &Self) -> bool {
                self.0 == other.0
            }
            fn ne(&self, other: &Self) -> bool {
                self.0 != other.0
            }
        }
        impl PartialEq<i32> for CurrentUser {
            fn eq(&self, other: &i32) -> bool {
                self.0 == *other
            }
            fn ne(&self, other: &i32) -> bool {
                self.0 != *other
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SECRET_KEY {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        static SECRET_KEY: SECRET_KEY = SECRET_KEY { __private_field: () };
        impl ::lazy_static::__Deref for SECRET_KEY {
            type Target = String;
            fn deref(&self) -> &String {
                #[inline(always)]
                fn __static_ref_initialize() -> String {
                    env::var("SECRET_KEY").expect("SECRET_KEY must be set")
                }
                #[inline(always)]
                fn __stability() -> &'static String {
                    static LAZY: ::lazy_static::lazy::Lazy<String> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SECRET_KEY {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        pub async fn create_token(
            user_id: i32,
            username: String,
            conn: &DatabaseConnection,
        ) -> Result<(String, String), AppError> {
            let now = chrono::Utc::now();
            let expires_at = now + Duration::minutes(15);
            let exp = expires_at.timestamp() as u64;
            let claims = JwtClaims {
                exp,
                user_id,
                username: username.clone(),
            };
            let token_header = Header::default();
            let key = EncodingKey::from_secret(SECRET_KEY.as_bytes());
            let jwt_res = encode(&token_header, &claims, &key)?;
            let refresh_res = create_refresh(user_id, username, now, conn).await?;
            Ok((jwt_res, refresh_res))
        }
        pub async fn create_refresh(
            user_id: i32,
            username: String,
            now: DateTime<Utc>,
            conn: &DatabaseConnection,
        ) -> Result<String, AppError> {
            let exp = now + Duration::days(15);
            let exp = exp.naive_utc();
            let claims = RefreshClaims { user_id, username };
            let token_header = Header::default();
            let key = EncodingKey::from_secret(SECRET_KEY.as_bytes());
            let res = encode(&token_header, &claims, &key)?;
            let active = refresh_token::ActiveModel {
                user_id: sea_orm::ActiveValue::Set(user_id),
                token: sea_orm::ActiveValue::Set(res.clone()),
                expires_at: sea_orm::ActiveValue::Set(exp),
            };
            refresh_token::Entity::insert(active)
                .on_conflict(
                    OnConflict::column(refresh_token::Column::Token)
                        .update_columns([
                            refresh_token::Column::UserId,
                            refresh_token::Column::ExpiresAt,
                        ])
                        .to_owned(),
                )
                .exec(conn)
                .await?;
            Ok(res)
        }
        pub fn validate_jwt_token(
            token: &str,
        ) -> Result<JwtClaims, jsonwebtoken::errors::Error> {
            let binding = token.replace("Bearer ", "");
            let key = DecodingKey::from_secret(SECRET_KEY.as_bytes());
            let mut validation = Validation::new(jsonwebtoken::Algorithm::HS256);
            validation.leeway = 60;
            let res = decode::<JwtClaims>(&binding, &key, &validation)
                .map_err(|e| e)
                .and_then(|decoded| Ok(decoded.claims))?;
            Ok(res)
        }
        pub fn validate_jwt_token_without_exp(
            token: &str,
        ) -> Result<JwtClaims, jsonwebtoken::errors::Error> {
            let binding = token.replace("Bearer ", "");
            let key = DecodingKey::from_secret(SECRET_KEY.as_bytes());
            let mut validation = Validation::new(jsonwebtoken::Algorithm::HS256);
            validation.validate_exp = false;
            let res = decode::<JwtClaims>(&binding, &key, &validation)
                .map_err(|e| e)
                .and_then(|decoded| Ok(decoded.claims))?;
            Ok(res)
        }
        pub fn validate_refresh_token(
            token: &str,
        ) -> Result<RefreshClaims, jsonwebtoken::errors::Error> {
            let binding = token.replace("Bearer ", "");
            let key = DecodingKey::from_secret(SECRET_KEY.as_bytes());
            let mut validation = Validation::new(jsonwebtoken::Algorithm::HS256);
            validation.validate_exp = false;
            validation.required_spec_claims.remove("exp");
            let res = decode::<RefreshClaims>(&binding, &key, &validation)
                .map_err(|e| e)
                .and_then(|decoded| Ok(decoded.claims))?;
            Ok(res)
        }
        pub async fn authenticate(
            headers: HeaderMap,
            mut request: Request<Body>,
            next: Next,
        ) -> Result<Response, AppError> {
            if let Some(value) = headers.get(AUTHORIZATION) {
                let token = value.to_str()?;
                let claim = validate_jwt_token(token)?;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event fullstack/src/utils/jwt.rs:170",
                                "fullstack::utils::jwt",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack/src/utils/jwt.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(170u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "fullstack::utils::jwt",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::DEBUG {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::DEBUG {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set_all(
                                    &[
                                        (::tracing::__macro_support::Option::Some(
                                            &format_args!("Authenticated user: {0}", claim.user_id)
                                                as &dyn ::tracing::field::Value,
                                        )),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::DEBUG {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::DEBUG {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set_all(
                                                            &[
                                                                (::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Authenticated user: {0}", claim.user_id)
                                                                        as &dyn ::tracing::field::Value,
                                                                )),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                request
                    .extensions_mut()
                    .insert(CurrentUser(claim.user_id, claim.username));
                Ok(next.run(request).await)
            } else {
                Err(AppError::any_t_error(String::from_str("Authorization not found")))
            }
        }
    }
}
pub mod ws {
    mod chat {
        use axum::{
            Extension, body,
            extract::{State, WebSocketUpgrade, ws::{Message, WebSocket}},
            http::Response,
        };
        use futures_util::{SinkExt, StreamExt};
        use crate::{utils::jwt::CurrentUser, ws::state::ChatChannel};
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        pub struct __path_chat_ws_handler;
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for __path_chat_ws_handler {
            #[inline]
            fn clone(&self) -> __path_chat_ws_handler {
                __path_chat_ws_handler
            }
        }
        impl<'t> utoipa::__dev::Tags<'t> for __path_chat_ws_handler {
            fn tags() -> Vec<&'t str> {
                [super::TAG].into()
            }
        }
        impl utoipa::Path for __path_chat_ws_handler {
            fn path() -> String {
                String::from("/chat")
            }
            fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
                [utoipa::openapi::HttpMethod::Get].into()
            }
            fn operation() -> utoipa::openapi::path::Operation {
                use utoipa::openapi::ToArray;
                use std::iter::FromIterator;
                utoipa::openapi::path::OperationBuilder::new()
                    .responses(utoipa::openapi::ResponsesBuilder::new().build())
                    .securities(
                        Some([
                            utoipa::openapi::security::SecurityRequirement::default()
                                .add::<&str, [&str; 0usize], &str>("api_jwt_token", []),
                        ]),
                    )
                    .operation_id(Some("chat_ws_handler"))
                    .description(
                        Some(
                            "   UI  ,    curl \n\n  https://github.com/vi/websocat  ",
                        ),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("Connection"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .example(Some(::serde_json::to_value(&"Upgrade").unwrap()))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("Upgrade"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .example(Some(::serde_json::to_value(&"websocket").unwrap()))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new("Sec-WebSocket-Key"),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .example(
                                Some(
                                    ::serde_json::to_value(&"dGhlIHNhbXBsZSBub25jZQ==").unwrap(),
                                ),
                            )
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::String,
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .parameter(
                        utoipa::openapi::path::ParameterBuilder::from(
                                utoipa::openapi::path::Parameter::new(
                                    "Sec-WebSocket-Version",
                                ),
                            )
                            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                            .example(Some(::serde_json::to_value(&13).unwrap()))
                            .schema(
                                Some(
                                    utoipa::openapi::ObjectBuilder::new()
                                        .schema_type(
                                            utoipa::openapi::schema::SchemaType::new(
                                                utoipa::openapi::schema::Type::Integer,
                                            ),
                                        )
                                        .format(
                                            Some(
                                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                    utoipa::openapi::schema::KnownFormat::Int32,
                                                ),
                                            ),
                                        ),
                                ),
                            )
                            .required(utoipa::openapi::Required::True),
                    )
                    .into()
            }
        }
        impl utoipa::__dev::SchemaReferences for __path_chat_ws_handler {
            fn schemas(
                schemas: &mut Vec<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >,
            ) {}
        }
        pub async fn chat_ws_handler(
            ws: WebSocketUpgrade,
            Extension(user): Extension<CurrentUser>,
            State(chat): State<ChatChannel>,
        ) -> Response<body::Body> {
            ws.on_upgrade(|socket| chat_socket_handler(socket, chat, user.1))
        }
        async fn chat_socket_handler(
            ws: WebSocket,
            chat: ChatChannel,
            username: String,
        ) {
            let (mut wtx, mut wrx) = ws.split();
            let mut rx = chat.lock().await.subscribe();
            let mut sender = async move || {
                while let Ok(msg) = rx.recv().await {
                    if wtx.send(msg).await.is_err() {
                        break;
                    }
                }
            };
            let mut reciver = async move || {
                if chat
                    .lock()
                    .await
                    .send(
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} is Connected", username),
                                )
                            })
                            .into(),
                    )
                    .is_err()
                {}
                while let Some(Ok(msg)) = wrx.next().await {
                    match msg {
                        Message::Close(_) => {
                            break;
                        }
                        m => {
                            let m = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: {1}",
                                        username,
                                        m.to_text().unwrap_or_default(),
                                    ),
                                )
                            });
                            if chat.lock().await.send(Message::Text(m.into())).is_err() {
                                break;
                            }
                        }
                    }
                }
                if chat
                    .lock()
                    .await
                    .send(
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} is Disconnected", username),
                                )
                            })
                            .into(),
                    )
                    .is_err()
                {}
            };
            let (_, _) = {
                let mut futures = (
                    ::tokio::macros::support::maybe_done(sender()),
                    ::tokio::macros::support::maybe_done(reciver()),
                );
                let mut futures = &mut futures;
                let mut rotator = <::tokio::macros::support::SelectNormal as ::tokio::macros::support::RotatorSelect>::Rotator::<
                    { 0 + 1 + 1 },
                >::default();
                ::tokio::macros::support::poll_fn(move |cx| {
                        const COUNT: u32 = 0 + 1 + 1;
                        let mut is_pending = false;
                        let mut to_run = COUNT;
                        let mut skip = rotator.num_skip();
                        loop {
                            if skip == 0 {
                                if to_run == 0 {
                                    break;
                                }
                                to_run -= 1;
                                let (fut, ..) = &mut *futures;
                                let mut fut = unsafe {
                                    ::tokio::macros::support::Pin::new_unchecked(fut)
                                };
                                if ::tokio::macros::support::Future::poll(fut.as_mut(), cx)
                                    .is_pending()
                                {
                                    is_pending = true;
                                }
                            } else {
                                skip -= 1;
                            }
                            if skip == 0 {
                                if to_run == 0 {
                                    break;
                                }
                                to_run -= 1;
                                let (_, fut, ..) = &mut *futures;
                                let mut fut = unsafe {
                                    ::tokio::macros::support::Pin::new_unchecked(fut)
                                };
                                if ::tokio::macros::support::Future::poll(fut.as_mut(), cx)
                                    .is_pending()
                                {
                                    is_pending = true;
                                }
                            } else {
                                skip -= 1;
                            }
                        }
                        if is_pending {
                            ::tokio::macros::support::Poll::Pending
                        } else {
                            ::tokio::macros::support::Poll::Ready((
                                {
                                    let (fut, ..) = &mut futures;
                                    let mut fut = unsafe {
                                        ::tokio::macros::support::Pin::new_unchecked(fut)
                                    };
                                    fut.take_output().expect("expected completed future")
                                },
                                {
                                    let (_, fut, ..) = &mut futures;
                                    let mut fut = unsafe {
                                        ::tokio::macros::support::Pin::new_unchecked(fut)
                                    };
                                    fut.take_output().expect("expected completed future")
                                },
                            ))
                        }
                    })
                    .await
            };
        }
    }
    pub mod state {
        use std::sync::Arc;
        use axum::extract::{FromRef, ws::Message};
        use tokio::sync::{Mutex, broadcast::{self, Sender}};
        pub type ChatChannel = Arc<Mutex<Sender<Message>>>;
        pub struct WsState {
            pub channel: ChatChannel,
        }
        #[allow(clippy::clone_on_copy, clippy::clone_on_ref_ptr)]
        impl ::axum::extract::FromRef<WsState> for ChatChannel {
            fn from_ref(state: &WsState) -> Self {
                state.channel.clone()
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WsState {
            #[inline]
            fn clone(&self) -> WsState {
                WsState {
                    channel: ::core::clone::Clone::clone(&self.channel),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WsState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "WsState",
                    "channel",
                    &&self.channel,
                )
            }
        }
        pub fn init_state() -> WsState {
            let (sender, _) = broadcast::channel(32);
            WsState {
                channel: Arc::new(Mutex::new(sender)),
            }
        }
    }
    use axum::{
        extract::{WebSocketUpgrade, ws::{Message, WebSocket}},
        response::IntoResponse,
    };
    use futures_util::{SinkExt, StreamExt};
    use tracing::debug;
    use utoipa::OpenApi;
    use utoipa_axum::{router::OpenApiRouter, routes};
    use utoipa_scalar::{Scalar, Servable};
    use crate::{
        resources::dto::fullstack_extension::AppExtension,
        router::api::{ApiRouters, auth::SecurityAddon},
    };
    pub const TAG: &str = "WebSocket";
    #[openapi(
        servers((url = "/ws", description = "WebSocket Api Doc")),
        modifiers(&SecurityAddon),
        tags((name = TAG, description = "WebSocket Api Tag"))
    )]
    struct ApiDoc;
    impl utoipa::OpenApi for ApiDoc {
        fn openapi() -> utoipa::openapi::OpenApi {
            use utoipa::{ToSchema, Path};
            let mut openapi = utoipa::openapi::OpenApiBuilder::new()
                .info(
                    utoipa::openapi::InfoBuilder::new()
                        .title("fullstack")
                        .version("0.1.0")
                        .description(Some(""))
                        .license(
                            Some(
                                utoipa::openapi::info::LicenseBuilder::new()
                                    .name("")
                                    .build(),
                            ),
                        ),
                )
                .paths({ utoipa::openapi::path::PathsBuilder::new() })
                .tags(
                    Some([
                        utoipa::openapi::tag::TagBuilder::new()
                            .name(TAG)
                            .description(Some("WebSocket Api Tag"))
                            .build(),
                    ]),
                )
                .servers(
                    Some([
                        utoipa::openapi::server::ServerBuilder::new()
                            .url("/ws")
                            .description(Some("WebSocket Api Doc"))
                            .build(),
                    ]),
                )
                .build();
            let components = openapi
                .components
                .get_or_insert(utoipa::openapi::Components::new());
            let mut schemas = Vec::<
                (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
            >::new();
            components.schemas.extend(schemas);
            let _mods: [&dyn utoipa::Modify; 1usize] = [&SecurityAddon];
            _mods.iter().for_each(|modifier| modifier.modify(&mut openapi));
            openapi
        }
    }
    pub fn init_router(aex: AppExtension) -> ApiRouters {
        let auth_router = OpenApiRouter::new()
            .routes({
                use ::utoipa_axum::PathItemExt;
                let mut paths = utoipa::openapi::path::Paths::new();
                let mut schemas = Vec::<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >::new();
                let (path, item, types) = {
                    let path = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        __path_websocket_handler::path()
                    };
                    let mut operation = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        __path_websocket_handler::operation()
                    };
                    let types = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        __path_websocket_handler::methods()
                    };
                    let tags = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        __path_websocket_handler::tags()
                    };
                    {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        __path_websocket_handler::schemas(&mut schemas)
                    };
                    if !tags.is_empty() {
                        let operation_tags = operation.tags.get_or_insert(Vec::new());
                        operation_tags.extend(tags.iter().map(ToString::to_string));
                    }
                    (path, operation, types)
                };
                #[allow(unused_mut)]
                let mut method_router = types
                    .iter()
                    .by_ref()
                    .fold(
                        axum::routing::MethodRouter::new(),
                        |router, path_type| {
                            router.on(path_type.to_method_filter(), websocket_handler)
                        },
                    );
                paths.add_path_operation(&path, types, item);
                (schemas, paths, method_router)
            })
            .routes({
                use ::utoipa_axum::PathItemExt;
                let mut paths = utoipa::openapi::path::Paths::new();
                let mut schemas = Vec::<
                    (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
                >::new();
                let (path, item, types) = {
                    let path = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        chat::__path_chat_ws_handler::path()
                    };
                    let mut operation = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        chat::__path_chat_ws_handler::operation()
                    };
                    let types = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        chat::__path_chat_ws_handler::methods()
                    };
                    let tags = {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        chat::__path_chat_ws_handler::tags()
                    };
                    {
                        #[allow(unused_imports)]
                        use utoipa::{Path, __dev::{Tags, SchemaReferences}};
                        chat::__path_chat_ws_handler::schemas(&mut schemas)
                    };
                    if !tags.is_empty() {
                        let operation_tags = operation.tags.get_or_insert(Vec::new());
                        operation_tags.extend(tags.iter().map(ToString::to_string));
                    }
                    (path, operation, types)
                };
                #[allow(unused_mut)]
                let mut method_router = types
                    .iter()
                    .by_ref()
                    .fold(
                        axum::routing::MethodRouter::new(),
                        |router, path_type| {
                            router
                                .on(path_type.to_method_filter(), chat::chat_ws_handler)
                        },
                    );
                paths.add_path_operation(&path, types, item);
                (schemas, paths, method_router)
            })
            .with_state(aex.ws.clone());
        let unauth_router = OpenApiRouter::new().with_state(aex.ws);
        let (auth_router, auth_api) = auth_router.split_for_parts();
        let (unauth_router, unauth_api) = unauth_router.split_for_parts();
        let mut api = ApiDoc::openapi();
        api.merge(auth_api);
        api.merge(unauth_api);
        let unauth_router = unauth_router.merge(Scalar::with_url("/doc/scalar", api));
        ApiRouters {
            auth: auth_router,
            unauth: unauth_router,
        }
            .new_nest("/ws")
    }
    #[allow(non_camel_case_types)]
    #[doc(hidden)]
    pub struct __path_websocket_handler;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for __path_websocket_handler {
        #[inline]
        fn clone(&self) -> __path_websocket_handler {
            __path_websocket_handler
        }
    }
    impl<'t> utoipa::__dev::Tags<'t> for __path_websocket_handler {
        fn tags() -> Vec<&'t str> {
            [TAG].into()
        }
    }
    impl utoipa::Path for __path_websocket_handler {
        fn path() -> String {
            String::from("/test")
        }
        fn methods() -> Vec<utoipa::openapi::path::HttpMethod> {
            [utoipa::openapi::HttpMethod::Get].into()
        }
        fn operation() -> utoipa::openapi::path::Operation {
            use utoipa::openapi::ToArray;
            use std::iter::FromIterator;
            utoipa::openapi::path::OperationBuilder::new()
                .responses(utoipa::openapi::ResponsesBuilder::new().build())
                .securities(
                    Some([
                        utoipa::openapi::security::SecurityRequirement::default()
                            .add::<&str, [&str; 0usize], &str>("api_jwt_token", []),
                    ]),
                )
                .operation_id(Some("websocket_handler"))
                .description(
                    Some(
                        "   UI  ,    curl \n\n  https://github.com/vi/websocat  ",
                    ),
                )
                .parameter(
                    utoipa::openapi::path::ParameterBuilder::from(
                            utoipa::openapi::path::Parameter::new("Connection"),
                        )
                        .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                        .example(Some(::serde_json::to_value(&"Upgrade").unwrap()))
                        .schema(
                            Some(
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            ),
                        )
                        .required(utoipa::openapi::Required::True),
                )
                .parameter(
                    utoipa::openapi::path::ParameterBuilder::from(
                            utoipa::openapi::path::Parameter::new("Upgrade"),
                        )
                        .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                        .example(Some(::serde_json::to_value(&"websocket").unwrap()))
                        .schema(
                            Some(
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            ),
                        )
                        .required(utoipa::openapi::Required::True),
                )
                .parameter(
                    utoipa::openapi::path::ParameterBuilder::from(
                            utoipa::openapi::path::Parameter::new("Sec-WebSocket-Key"),
                        )
                        .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                        .example(
                            Some(
                                ::serde_json::to_value(&"dGhlIHNhbXBsZSBub25jZQ==").unwrap(),
                            ),
                        )
                        .schema(
                            Some(
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::String,
                                        ),
                                    ),
                            ),
                        )
                        .required(utoipa::openapi::Required::True),
                )
                .parameter(
                    utoipa::openapi::path::ParameterBuilder::from(
                            utoipa::openapi::path::Parameter::new(
                                "Sec-WebSocket-Version",
                            ),
                        )
                        .parameter_in(utoipa::openapi::path::ParameterIn::Header)
                        .example(Some(::serde_json::to_value(&13).unwrap()))
                        .schema(
                            Some(
                                utoipa::openapi::ObjectBuilder::new()
                                    .schema_type(
                                        utoipa::openapi::schema::SchemaType::new(
                                            utoipa::openapi::schema::Type::Integer,
                                        ),
                                    )
                                    .format(
                                        Some(
                                            utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                                utoipa::openapi::schema::KnownFormat::Int32,
                                            ),
                                        ),
                                    ),
                            ),
                        )
                        .required(utoipa::openapi::Required::True),
                )
                .into()
        }
    }
    impl utoipa::__dev::SchemaReferences for __path_websocket_handler {
        fn schemas(
            schemas: &mut Vec<
                (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
            >,
        ) {}
    }
    async fn websocket_handler(ws: WebSocketUpgrade) -> impl IntoResponse {
        ws.on_upgrade(handler_socket)
    }
    async fn handler_socket(ws: WebSocket) {
        let (mut ws_tx, mut ws_rx) = ws.split();
        while let Some(Ok(msg)) = ws_rx.next().await {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event fullstack/src/ws/mod.rs:83",
                            "fullstack::ws",
                            ::tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "fullstack/src/ws/mod.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(83u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "fullstack::ws",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::DEBUG
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::DEBUG {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::DEBUG {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set_all(
                                &[
                                    (::tracing::__macro_support::Option::Some(
                                        &format_args!(
                                            "Message received: {0}",
                                            msg.to_text().unwrap_or_default(),
                                        ) as &dyn ::tracing::field::Value,
                                    )),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::DEBUG {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::DEBUG {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set_all(
                                                        &[
                                                            (::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Message received: {0}",
                                                                    msg.to_text().unwrap_or_default(),
                                                                ) as &dyn ::tracing::field::Value,
                                                            )),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            ws_tx
                .send(
                    Message::Text(
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Message received: {0}",
                                        msg.to_text().unwrap_or_default(),
                                    ),
                                )
                            })
                            .into(),
                    ),
                )
                .await
                .unwrap_or_default();
        }
    }
}
use crate::front::app;
fn main() {
    dioxus::serve(|| async move {
        use axum::Extension;
        use axum::{Router, routing::get};
        use middle::{init_middel_ware, time_out_test};
        use router::api::{self, auth};
        use router::hello::*;
        use crate::resources::dto::fullstack_extension;
        let fulex = fullstack_extension::AppExtension::init().await?;
        let api_routers = api::init_route(fulex.clone());
        let ws_routers = ws::init_router(fulex.clone());
        let hello_router = hello_router(fulex.clone());
        let login_router = auth::init_router(fulex.clone());
        let no_auth_router = Router::new()
            .nest("/hello", hello_router)
            .nest("/api/auth", login_router)
            .merge(api_routers.unauth)
            .merge(ws_routers.unauth)
            .merge(dioxus::server::router(app))
            .route("/middle/test", get(time_out_test));
        let auth_router = Router::new().merge(api_routers.auth).merge(ws_routers.auth);
        let app = Router::new().merge(auth_router).layer(Extension(fulex));
        let app = init_middel_ware(no_auth_router, app);
        Ok(app)
    });
}
